---
title: "Making Sam Block_Group Households"
author: "Dan Price"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
geometry: margin=1in
fontsize: 11pt
documentclass: article
header-includes: 
  - \usepackage{tikz}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Preliminaries -- very broad
https://kbroman.org/knitr_knutshell/pages/Rmarkdown.html for options on the knit - results="hide"; echo=FALSE; include=FALSE, etc.

```{r prelims}
source('BaseScripts/Census_Data.R') #move out of BaseScripts?
source('tests.R')
library(tidyr)
library(dplyr)
library(stringr)
library(data.table)
#maindir = "~/University Of Houston/Price, Daniel M - Social Network Hypergraphs/"
#maindir = "~/Downloads/UH_OneDrive/OneDrive\ -\ University\ Of\ Houston/Social\ Network\ Hypergraphs/" #Dan at home
#maindir = "~/Downloads/OneDrive\ -\ University\ Of\ Houston/Social\ Network\ Hypergraphs/" #Dan at work
maindir = "/Users/areb219/Library/CloudStorage/OneDrive-UniversityOfHouston/Social\ Network\ Hypergraphs/" #Dan at AREB219
housingdir = paste0(maindir,"HCAD/")
houstondatadir = paste0(maindir,"HoustonCityData/") 
censusdir = paste0(maindir,"Census/") 
vintage = "2020"
housingStockFromRDS = TRUE 
#numberOfCores = 1
state = 48 #48 Texas; 22 Louisiana
county = 201 #8 county region: 201 Harris; 157 Fort Bend; 167 Galveston; 039 Brazoria; 071 Chambers; 291 Liberty; 339 Montgomery; 473 Waller ; other place FIPS are longer
st_county = paste0(state,county)
tract = "*"
Sam_seed = 135
#you don't need a censuskey if you're not pulling new files down; you can only use this one if you have correct access to the OneDrive
censuskey <- readLines(paste0(censusdir, "2017", "/key"))

#need to think through the  part of the naming throughout...
```


```{r add P16 hh type race and eth}
#1
bg_hh_type_race_eth_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P16", county_num = "*",
                         block="block_group", api_type="dec/dhc",
                         path_suff="est.csv")
```

The households have data associated with them, and each household will have an id. The head of household is given extra tables, although there are reasons to think hard about the various ways in which head of household is designated and only recently has the census allowed for female head of household when a male is present.
The one with household type, race and ethnicity will serve as our base, and so we'll call it bgHH. 

```{r set up bgHH from bg_hh_type_race_eth_data_from_census}
bgHH_data <- as.data.table(bg_hh_type_race_eth_data_from_census)
bgHH_data[,6:ncol(bgHH_data)] <- 
  bgHH_data[,lapply(.SD[,6:ncol(bgHH_data)], as.numeric)]
bgHH_data[,c("predicateOnly","hasGeoCollectionSupport"):=NULL]
rm(bg_hh_type_race_eth_data_from_census)

#feed to test.R - doesn't work for totals because of how ethnicity is counted. So just make sure pop totals work
#check_summary <- census_table_check(bgHH_data, "HOUSEHOLD TYPE","household"," !!Total:",2)
#cat(check_summary)

#make a totals file and check that way
pop_totals_hh <- bgHH_data[name=="P16_001N",4:ncol(bgHH_data)] #number for whole state
sum(pop_totals_hh[,],na.rm = TRUE) #==sum(pop_totals_bg[,],na.rm = TRUE)
paste0("Number of block groups in Texas: ", ncol(bgHH_data[,4:ncol(bgHH_data)]))
paste0("Average number of households in block groups: ", as.integer(mean(as.numeric(pop_totals_hh[,]),na.rm = TRUE)))
paste0("Median number of households in block groups: ", as.integer(median(as.numeric(pop_totals_hh[,]),na.rm = TRUE)))
paste0("Maximum number of households in block group: ", max(as.numeric(pop_totals_hh[,]),na.rm = TRUE))
paste0("Minimum number of households in block group: ", min(as.numeric(pop_totals_hh[,]),na.rm = TRUE))

#make long
bgHH_dec <- bgHH_data %>%
  filter(label!=" !!Total:") %>% #sometimes doesn't have the beginning space!!!???
  mutate(label=str_remove(label,"!!Total:!!"),
         label=str_remove(label,"!!Other family:"),
         label=str_remove(label,"!!Other family:")) %>%
  pivot_longer(4:ncol(bgHH_data),names_to = "geoid", values_to = "number_sams",
               names_transform = list(geoid=as.character)) %>%
  filter(str_detect(geoid,"48_201")) %>% #for test, only Harris
  separate(label, c("family","hh_type"), sep = ":!!", remove = F, convert = FALSE) %>%
  mutate(
    geoid = str_remove_all(geoid,"_"),
    tract = substr(geoid,1,11),
    re_code = substr(name,4,4),
    race_description = str_replace(concept,"HOUSEHOLD TYPE \\(",""),
    race_description = str_replace(race_description,"\\)",""),
    HvL = if_else(str_detect(race_description,"NOT"),FALSE,TRUE),
    race = case_when(re_code=="I" ~ "A",
                      re_code=="P" ~ "A",
                      re_code=="J" ~ "B",
                      re_code=="Q" ~ "B",
                      re_code=="K" ~ "C",
                      re_code=="R" ~ "C",
                      re_code=="L" ~ "D",
                      re_code=="S" ~ "D",
                      re_code=="M" ~ "E",
                      re_code=="T" ~ "E",
                      re_code=="N" ~ "F",
                      re_code=="U" ~ "F",
                      re_code=="O" ~ "G",
                      re_code=="V" ~ "G",
                     TRUE ~ "No match")
    ) %>%
  filter(number_sams > 0, !is.na(hh_type) & str_detect(race_description,"HISPANIC") & re_code != "H") %>% 
  select(-c(name,label,concept)) %>%
  uncount(number_sams,.id = "hh_type_race_id")
nrow(bgHH_dec)==sum(pop_totals_hh[,], na.rm = TRUE)  
bgHH_dec <- as.data.table(bgHH_dec)
rm(bgHH_data)
rm(pop_totals_hh)
```

#add age tenure for hh with race and ethnicity
```{r add age tenure to bgHH with race and ethnicity}
#2
bg_hh_age_tenure_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "H13", county_num = "*",
                         block="block_group", api_type="dec/dhc",
                         path_suff="est.csv")
bgHH_age_data <- as.data.table(bg_hh_age_tenure_data_from_census)
bgHH_age_data[,6:ncol(bgHH_age_data)] <- 
  bgHH_age_data[,lapply(.SD[,6:ncol(bgHH_age_data)], as.numeric)]
bgHH_age_data[,c("predicateOnly","hasGeoCollectionSupport"):=NULL]
rm(bg_hh_age_tenure_data_from_census)

#feed to test.R (doesn't work with the Hispanic or Latino in there in it's odd way)

#uncount by race and by Hispanic or Latino (HvL)
bgHH_age <- bgHH_age_data %>%
  filter(label!="!!Total:") %>%
  mutate(label=str_remove(label,"!!Total:!!")) %>%
  pivot_longer(4:ncol(bgHH_age_data),names_to = "geoid", values_to = "number_sams",
               names_transform = list(geoid=as.character)) %>%
  filter(str_detect(geoid,"48_201")) %>% #for test, only Harris
  separate(label, c("rent_own","hh_age_range"), sep = ":!!", remove = F, convert = FALSE) %>%
  mutate(
    geoid = str_remove_all(geoid,"_"),
    tract = substr(geoid,1,11),
    race = substr(name,4,4),
    race_description_tenure = str_replace(concept,"TENURE BY AGE OF HOUSEHOLDER \\(",""),
    race_description_tenure = str_replace(race_description_tenure,"\\)",""),
    hh_age_range_3 = case_when(hh_age_range=="Householder 15 to 24 years" | 
                                 hh_age_range=="Householder 25 to 34 years" ~ "Householder 15 to 34 years",
                               hh_age_range=="Householder 35 to 44 years" | 
                                 hh_age_range=="Householder 45 to 54 years" |
                                 hh_age_range=="Householder 55 to 59 years" |
                                 hh_age_range=="Householder 60 to 64 years" ~ "Householder 35 to 64 years",
                               hh_age_range=="Householder 65 to 74 years" | 
                                 hh_age_range=="Householder 75 to 84 years" |
                                 hh_age_range=="Householder 85 years and over" ~ "Householder 65 years and over")
    ) %>%
  filter(number_sams > 0, !is.na(hh_age_range)) %>% 
  select(-c(name,label,concept)) 

race_codes <- c("A","B","C","D","E","F","G")
bgHH_age_race <- bgHH_age %>%
  filter(race %in% race_codes) %>%
  uncount(number_sams,.id = "hh_age_race_id")
nrow(bgHH_dec)==nrow(bgHH_age_race)
bgHH_age_race <- as.data.table(bgHH_age_race)

bgHH_age_eth <- bgHH_age %>%
  filter(race=="H") %>%
  uncount(number_sams,.id = "hh_age_eth_id")
nrow(bgHH_dec[HvL==TRUE])==nrow(bgHH_age_eth)
bgHH_age_eth <- as.data.table(bgHH_age_eth)
bgHH_age_eth[,("HvL"):=TRUE]

test <- table(bgHH_dec[,geoid],
              bgHH_dec[,race]
              )==
        table(bgHH_age_race[,geoid],
              bgHH_age_race[,race]
              )
length(test[test==FALSE])==0

test <- table(bgHH_dec[HvL==TRUE,geoid],
              bgHH_dec[HvL==TRUE,HvL]
              )==
        table(bgHH_age_eth[,geoid],
              bgHH_age_eth[,HvL]
              )
length(test[test==FALSE])==0

rm(bgHH_age_data)
rm(bgHH_age)
```

#add type and tenure by race and ethnicity
```{r create hh type and tenure data}
#3
bg_hh_type_tenure_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "H14", county_num = "*",
                         block="block_group", api_type="dec/dhc",
                         path_suff="est.csv")
bgHH_type_data <- as.data.table(bg_hh_type_tenure_data_from_census)
bgHH_type_data[,6:ncol(bgHH_type_data)] <- 
  bgHH_type_data[,lapply(.SD[,6:ncol(bgHH_type_data)], as.numeric)]
bgHH_type_data[,c("predicateOnly","hasGeoCollectionSupport"):=NULL]
rm(bg_hh_type_tenure_data_from_census)

#feed to test.R

#make long
bgHH_type <- bgHH_type_data %>%
  filter(label!="!!Total:") %>%
  mutate(label=str_remove(label,"!!Total:!!"),
         label=str_remove(label,"!!Other family:")) %>%
  pivot_longer(4:ncol(bgHH_type_data),names_to = "geoid", values_to = "number_sams",
               names_transform = list(geoid=as.character)) %>%
  filter(str_detect(geoid,"48_201")) %>% #for test, only Harris
  separate(label, c("rent_own","family","hh_type_fm","alone","hh_age_range_3"), sep = ":!!", remove = F, convert = FALSE) %>%
  mutate(
    geoid = str_remove_all(geoid,"_"),
    tract = substr(geoid,1,11),
    hh_age_range_3 = if_else(is.na(hh_age_range_3) & !str_detect(alone,"alone"),alone,hh_age_range_3),
    alone = if_else(str_detect(alone,"Living alone"),"Living alone","Not living alone"),
    hh_type = case_when(hh_type_fm=="Male householder" & alone == "Living alone" ~ "Householder living alone",
                        hh_type_fm=="Female householder" & alone == "Living alone" ~ "Householder living alone",
                        hh_type_fm=="Married couple" ~ "Married couple family",
                        str_detect(hh_type_fm,"spouse") ~ hh_type_fm,
                        TRUE ~ "Householder not living alone")
    ) %>%
  filter(number_sams > 0, !is.na(hh_age_range_3)) %>% 
  select(-c(name,label,concept)) %>%
  uncount(number_sams,.id = "hh_type_age_id")
nrow(bgHH_dec)==nrow(bgHH_type)
bgHH_type <- as.data.table(bgHH_type)

test <- table(bgHH_age_race[,geoid],
              bgHH_age_race[,hh_age_range_3],
              bgHH_age_race[,rent_own]
              )==
        table(bgHH_type[,geoid],
              bgHH_type[,hh_age_range_3],
              bgHH_type[,rent_own]
              )
length(test[test==FALSE])==0
test <- table(bgHH_dec[,geoid],
              bgHH_dec[,family],
              bgHH_dec[,hh_type]
              )==
        table(bgHH_type[,geoid],
              bgHH_type[,family],
              bgHH_type[,hh_type]
              )
length(test[test==FALSE])==0
rm(bgHH_type_data)
#tests
```

#get hh size
```{r get hh size data}
#4 
bg_hh_size_tenure_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "H12", county_num = "*",
                         block="block_group", api_type="dec/dhc",
                         path_suff="est.csv")
bgHH_size_data <- as.data.table(bg_hh_size_tenure_data_from_census)
bgHH_size_data[,6:ncol(bgHH_size_data)] <- 
  bgHH_size_data[,lapply(.SD[,6:ncol(bgHH_size_data)], as.numeric)]
bgHH_size_data[,c("predicateOnly","hasGeoCollectionSupport"):=NULL]
rm(bg_hh_size_tenure_data_from_census)

#feed to test.R

#uncount by race and by HvL
bgHH_size <- bgHH_size_data %>%
  filter(label!="!!Total:") %>%
  mutate(label=str_remove(label,"!!Total:!!")) %>%
  pivot_longer(4:ncol(bgHH_size_data),names_to = "geoid", values_to = "number_sams",
               names_transform = list(geoid=as.character)) %>%
  filter(str_detect(geoid,"48_201")) %>% #for test, only Harris
  separate(label, c("rent_own","hh_size"), sep = ":!!", remove = F, convert = FALSE) %>%
  mutate(
    geoid = str_remove_all(geoid,"_"),
    tract = substr(geoid,1,11),
    race = substr(name,4,4),
    race_description_size = str_replace(concept,"TENURE BY HOUSEHOLD SIZE \\(",""),
    race_description_size = str_replace(race_description_size,"\\)","")
    ) %>%
  filter(number_sams > 0, !is.na(hh_size)) %>% 
  select(-c(name,label,concept)) 

race_codes <- c("A","B","C","D","E","F","G")
bgHH_size_race <- bgHH_size %>%
  filter(race %in% race_codes) %>%
  uncount(number_sams,.id = "hh_size_race_id")
nrow(bgHH_dec)==nrow(bgHH_size_race)
bgHH_size_race <- as.data.table(bgHH_size_race)

bgHH_size_eth <- bgHH_size %>%
  filter(race=="H") %>%
  uncount(number_sams,.id = "hh_age_eth_id")
nrow(bgHH_dec[HvL==TRUE])==nrow(bgHH_size_eth)
bgHH_size_eth <- as.data.table(bgHH_size_eth)
bgHH_size_eth[,("HvL"):=TRUE]

test <- table(bgHH_dec[,geoid],
              bgHH_dec[,race]
              )==
        table(bgHH_size_race[,geoid],
              bgHH_size_race[,race]
              )
length(test[test==FALSE])==0

test <- table(bgHH_dec[HvL==TRUE,geoid],
              bgHH_dec[HvL==TRUE,HvL]
              )==
        table(bgHH_size_eth[,geoid],
              bgHH_size_eth[,HvL]
              )
length(test[test==FALSE])==0
#do a few more of the tests
rm(bgHH_size)
rm(bgHH_size_data)

tr_hh_size_family_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "PCT7", county_num = "*",
                         block="tract", api_type="dec/dhc",
                         path_suff="est.csv")
trHH_size_data <- as.data.table(tr_hh_size_family_data_from_census)
trHH_size_data[,6:ncol(trHH_size_data)] <- 
  trHH_size_data[,lapply(.SD[,6:ncol(trHH_size_data)], as.numeric)]
trHH_size_data[,c("predicateOnly","hasGeoCollectionSupport"):=NULL]
rm(tr_hh_size_family_data_from_census)

#feed to test.R

#uncount by race and by HvL
trHH_size <- trHH_size_data %>%
  filter(label!="!!Total:") %>%
  mutate(label=str_remove(label,"!!Total:!!")) %>%
  pivot_longer(4:ncol(trHH_size_data),names_to = "tract", values_to = "number_sams",
               names_transform = list(tract=as.character)) %>%
  filter(str_detect(tract,"48201")) %>% #for test, only Harris
  separate(label, c("family","hh_size"), sep = ":!!", remove = F, convert = FALSE) %>%
  mutate(
    race = substr(name,5,5),
    race_description_size = str_replace(concept,"HOUSEHOLD TYPE BY HOUSEHOLD SIZE \\(",""),
    race_description_size = str_replace(race_description_size,"\\)","")
    ) %>%
  filter(number_sams > 0, !is.na(hh_size)) %>% 
  select(-c(name,label,concept)) 

race_codes <- c("A","B","C","D","E","F","G")
trHH_size_race <- trHH_size %>%
  filter(race %in% race_codes) %>%
  uncount(number_sams,.id = "tr_hh_size_race_id")
nrow(bgHH_dec)==nrow(trHH_size_race)
trHH_size_race <- as.data.table(trHH_size_race)

trHH_size_eth <- trHH_size %>%
  filter(race=="H") %>%
  uncount(number_sams,.id = "tr_hh_age_eth_id")
nrow(bgHH_dec[HvL==TRUE])==nrow(trHH_size_eth)
trHH_size_eth <- as.data.table(trHH_size_eth)
trHH_size_eth[,("HvL"):=TRUE]

test <- table(trHH_size_race[,tract],
              trHH_size_race[,race]
              )==
        table(bgHH_size_race[,tract],
              bgHH_size_race[,race]
              )
length(test[test==FALSE])==0

test <- table(trHH_size_eth[,tract],
              trHH_size_eth[,HvL]
              )==
        table(bgHH_size_eth[,tract],
              bgHH_size_eth[,HvL]
              )
length(test[test==FALSE])==0
#do a few more of the tests
rm(trHH_size)
rm(trHH_size_data)
#add geoid to trHH_size_eth from dec
trHH_size_eth[,("trbgHH_ds_match_id"):=
                    paste0(tract,HvL,family,as.character(100000+sample(1:.N))),
                  by=.(tract,HvL,family)]
bgHH_dec[,("trbgHH_ds_match_id"):=
                    paste0(tract,HvL,family,as.character(100000+sample(1:.N))),
                  by=.(tract,HvL,family)]
bgHH_dec[,("hh_size_match"):=
                 trHH_size_eth[.SD, list(hh_size), on = .(trbgHH_ds_match_id)]]
trHH_size_eth[,("geoid"):=
                 bgHH_dec[.SD, list(geoid), on = .(trbgHH_ds_match_id)]]
nrow(trHH_size_eth[is.na(geoid)])==0

#add family from trHH_size to bgHH_size - see how much just the variation in race/eth keeps the family in the right block...
trHH_size_eth[,("trbgHH_sg_match_id"):=
                    paste0(tract,geoid,HvL,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,geoid,HvL,hh_size)]
bgHH_size_eth[,("trbgHH_sg_match_id"):=
                    paste0(tract,geoid,HvL,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,geoid,HvL,hh_size)]
bgHH_size_eth[,("family"):=
                 trHH_size_eth[.SD, list(family), on = .(trbgHH_sg_match_id)]]
trHH_size_eth[,("geoid_match"):=
                 bgHH_size_eth[.SD, list(geoid), on = .(trbgHH_sg_match_id)]]
nrow(bgHH_size_eth[is.na(family)]) #43801 non matches
#don't go back to _dec for full match - just trying to get in the right direction and triangulate
trHH_size_eth[,("trbgHH_s_match_id"):=
                    paste0(tract,HvL,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,HvL,hh_size)]
bgHH_size_eth[,("trbgHH_s_match_id"):=
                    paste0(tract,HvL,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,HvL,hh_size)]
bgHH_size_eth[,("family"):=
                 trHH_size_eth[.SD, list(family), on = .(trbgHH_s_match_id)]]
trHH_size_eth[,("geoid"):=
                 bgHH_size_eth[.SD, list(geoid), on = .(trbgHH_s_match_id)]]
nrow(bgHH_size_eth[is.na(family)])==0
test <- table(trHH_size_eth[,tract],
              trHH_size_eth[,geoid],
              trHH_size_eth[,family],
              trHH_size_eth[,HvL]
              )==
        table(bgHH_size_eth[,tract],
              bgHH_size_eth[,geoid],
              bgHH_size_eth[,family],
              bgHH_size_eth[,HvL]
              )
length(test[test==FALSE])==0

test <- table(bgHH_dec[HvL==TRUE,geoid],
              bgHH_dec[HvL==TRUE,family]
              )-
        table(bgHH_size_eth[,geoid],
              bgHH_size_eth[,family]
              )
length(test[test>0])
length(test[test>5]) #441
length(test[test>15]) #7
#for race
#add a possible geoid to tract
trHH_size_race[,("trbgHH_dsrg_match_id"):=
                    paste0(tract,race,family,as.character(100000+sample(1:.N))),
                  by=.(tract,race,family)]
bgHH_dec[,("trbgHH_dsrg_match_id"):=
                    paste0(tract,race,family,as.character(100000+sample(1:.N))),
                  by=.(tract,race,family)]
bgHH_dec[,("hh_sizer_match"):=
                 trHH_size_race[.SD, list(hh_size), on = .(trbgHH_dsrg_match_id)]]
trHH_size_race[,("geoid"):=
                 bgHH_dec[.SD, list(geoid), on = .(trbgHH_dsrg_match_id)]]
nrow(trHH_size_race[is.na(geoid)])==0
#add family to bg race from tract
trHH_size_race[,("trbgHH_sr_match_id"):=
                    paste0(geoid,race,hh_size,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size)]
bgHH_size_race[,("trbgHH_sr_match_id"):=
                    paste0(geoid,race,hh_size,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size)]
bgHH_size_race[,("family"):=
                 trHH_size_race[.SD, list(family), on = .(trbgHH_sr_match_id)]]
trHH_size_race[,("geoid"):=
                 bgHH_size_race[.SD, list(geoid), on = .(trbgHH_sr_match_id)]]
nrow(bgHH_size_race[is.na(family)])==0
#and at tract level
trHH_size_race[,("trbgHH_sr_match_id"):=
                    paste0(tract,race,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,race,hh_size)]
bgHH_size_race[,("trbgHH_sr_match_id"):=
                    paste0(tract,race,hh_size,as.character(100000+sample(1:.N))),
                  by=.(tract,race,hh_size)]
bgHH_size_race[,("family"):=
                 trHH_size_race[.SD, list(family), on = .(trbgHH_sr_match_id)]]
trHH_size_race[,("geoid"):=
                 bgHH_size_race[.SD, list(geoid), on = .(trbgHH_sr_match_id)]]
nrow(bgHH_size_race[is.na(family)])==0
test <- table(trHH_size_race[,tract],
              trHH_size_race[,geoid],
              trHH_size_race[,family],
              trHH_size_race[,race]
              )==
        table(bgHH_size_race[,tract],
              bgHH_size_race[,geoid],
              bgHH_size_race[,family],
              bgHH_size_race[,race]
              )
length(test[test==FALSE])==0

test <- table(bgHH_dec[,geoid],
              bgHH_dec[,race],
              bgHH_dec[,family]
              )-
        table(bgHH_size_race[,geoid],
              bgHH_size_race[,race],
              bgHH_size_race[,family]
              )
length(test) #39564
length(test[test>5]) #1245
length(test[test>15]) #123
test1 <- test / table(bgHH_dec[,geoid],
              bgHH_dec[,race],
              bgHH_dec[,family]
              )
median(test1[1:length(test1)],na.rm = TRUE)==0 #doing something stupid that makes mean = -Inf...
#for tr, could do order by family...
#test on others for bg after merge

```


FOR OVERALL: We're trying to show how the structure of statistical representation - at every point, see whether or not it's statistically likely that the individual is in a certain part of the conceptual space - loses structure. It's metaphysically based in the questions of epistemology, and not of making the representation that best captures the situation. (and those two framings don't converge). The idea that relations precede objects needs to be made mathematically precise. Category theory does that be giving precedence to the morphisms in the understanding of structure, as opposed to some idea of definition, and of either fitting in to the schema or not. One way that this is concrete is in terms of the space that something is destined to.
NEED to DIAGRAM it - idea is that the embeddings are left to the production, but also - as destination - give you a limit to the representation


bgHH_type - can we do an expand and then slice? it's a way of thinking of a co-limit... goes with thought about PES
if we do everyone on the cartesian product that could match by first two, and then subtract the ones that could match on the 3rd...
So, for every row that we would have matched by adding a sample, just do a left_join that saves multiples rows, then on the second leg of the triangle, do the sample, but back down to the smaller number. Think about as a Kan extension, and as a factorization on the objects - vs. thinking about it as a destination - where the domain is not some abstract realm of possible apperceptions, but is locally preserved structure.
bgHH_dec_expanded <- bgHH_dec[bgHH_type, on=c(geoid,family,hhtype)]
or - more brute force: bgHH_dec_expanded <- bgHH_dec with both options for rentown and three options for agerange3
then - what does it mean for bg_HH_type to constrain those options... per geoid there are only so many rent, etc...
erase every one that can't match - it's the upper limit of the adjunct.
then for the next factor, etc.
what counts as upper limit and lower limit??

how is that different from just doing weighted averages? How more like construction of domain and codomain?
Part is not to take each piece as an added piece of knowledge - constructing from what we know about the things - but as an added piece of structure that will tell us what we can know in the next step.
The duplicates will have duplicate hh_type_race_ids so that might be able to be used for the final "cut" - maybe it's part of the construction on the matching, so that from the right side, we're referring to it somehow.

What we'll do is add bgHH_age/eth to bgHH_dec: start by adding eth to race, with a join that creates extra rows if no match and doesn't add more columns... in order to do that, look at some particular rows...


Trying to think about what it means to iterate through construction / composition. The sense of structure that goes along with the reception of a deployment of possibilities...

```{r join bgHH_age_eth to size, type, and dec}
#then do the match
#we have been given the number of single people households with a senior present - which gives us some ages
#first add hh_size, since the one-person family will help matches on type
bgHH_age_eth[,("bgHH_aes_match_id"):=
                    paste0(geoid,HvL,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,rent_own)]
bgHH_size_eth[,("bgHH_aes_match_id"):=
                    paste0(geoid,HvL,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,rent_own)]
bgHH_age_eth[,c("hh_size","family"):=
                 bgHH_size_eth[.SD, c(list(hh_size),list(family)), on = .(bgHH_aes_match_id)]]
nrow(bgHH_age_eth[is.na(hh_size)])==0 
nrow(bgHH_age_eth[is.na(family)])==0
#move HvL and race from _dec to type, based on family and type, and rent_own to dec
bgHH_type[,("bgHH_ad_match_id"):=
                    paste0(geoid,hh_type,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_type,family)]
bgHH_dec[,("bgHH_ad_match_id"):=
                    paste0(geoid,hh_type,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_type,family)]
bgHH_type[,c("HvL","race"):=
                 bgHH_dec[.SD, c(list(HvL),list(race)), on = .(bgHH_ad_match_id)]]
bgHH_dec[,c("rent_own","hh_age_range_3","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(rent_own),list(hh_age_range_3),
                                  list(hh_type_fm),list(alone)), on = .(bgHH_ad_match_id)]]
nrow(bgHH_type[HvL==TRUE])==nrow(bgHH_age_eth) 
nrow(bgHH_dec[!is.na(rent_own)])==nrow(bgHH_type[!is.na(HvL)])
nrow(bgHH_dec[HvL==TRUE])==nrow(bgHH_type[HvL==TRUE])

#move single family households over from type to age: - families are good at tract level for age, but not geoid
bgHH_age_eth[hh_size=="1-person household",("bgHH_aet1_match_id"):=
                    paste0(geoid,HvL,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,hh_age_range_3,rent_own,family)]
bgHH_type[alone=="Living alone",("bgHH_aet1_match_id"):=
                    paste0(geoid,HvL,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,hh_age_range_3,rent_own,family)]
bgHH_age_eth[hh_size=="1-person household",c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_aet1_match_id)]]
bgHH_type[alone=="Living alone",("age_eth_matched"):=
                 bgHH_age_eth[.SD, list(HvL), on = .(bgHH_aet1_match_id)]]
nrow(bgHH_age_eth[hh_size=="1-person household"])-nrow(bgHH_age_eth[!is.na(hh_type)]) #22,678
#make those hh have HvL False, so that when the HvL_ae (which will all be True) is counted, we can see what dropped
bgHH_type[alone=="Living alone" & is.na(age_eth_matched),("HvL"):=ifelse(HvL==TRUE,FALSE,FALSE)]

#one person households with HvL_ae coming from age, potentially overriding from dec - 
#if put them on here, it causes older values to go NA


#START HERE!!! - do we want to change it so that HvL is in first two iterations for matching?? I think yes, but can't remember what I did...
bgHH_age_eth[hh_size=="1-person household" & is.na(hh_type),("bgHH_aet2_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own)]
bgHH_type[alone=="Living alone" & is.na(age_eth_matched),("bgHH_aet2_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own)]
bgHH_age_eth[hh_size=="1-person household" & is.na(hh_type),c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_aet2_match_id)]]
bgHH_type[alone=="Living alone" & is.na(age_eth_matched),c("age_eth_matched","HvL_ae"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(HvL)), on = .(bgHH_aet2_match_id)]]
nrow(bgHH_age_eth[hh_size=="1-person household"])-nrow(bgHH_age_eth[!is.na(hh_type)]) #2,354
#then the more than 1 person households
bgHH_age_eth[hh_size!="1-person household",("bgHH_aet_match_id"):=
                    paste0(geoid,HvL,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,hh_age_range_3,rent_own,family)]
bgHH_type[alone!="Living alone",("bgHH_aet_match_id"):=
                    paste0(geoid,HvL,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL,hh_age_range_3,rent_own,family)]
bgHH_age_eth[hh_size!="1-person household",c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_aet_match_id)]]
bgHH_type[alone!="Living alone",c("age_eth_matched","HvL_ae"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(HvL)), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth[is.na(hh_type)]) #58466
#then without HvL (could compare with doing it without hh_age_range_3)
bgHH_age_eth[is.na(hh_type),("bgHH_aet_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_type[is.na(age_eth_matched),("bgHH_aet_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_age_eth[is.na(hh_type),c("hh_type","hh_type_fm","alone"):= #,"geoid" - maybe play with that later
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),
                                  list(alone)), on = .(bgHH_aet_match_id)]] #,list(geoid)
bgHH_type[is.na(age_eth_matched),c("age_eth_matched","HvL_ae"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(HvL)), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth[is.na(hh_type)]) #3867 
#and without hh_age_range_3
bgHH_age_eth[is.na(hh_type),("bgHH_aet_match_id"):=
                    paste0(geoid,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,rent_own,family)]
bgHH_type[is.na(age_eth_matched),("bgHH_aet_match_id"):=
                    paste0(geoid,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,rent_own,family)]
bgHH_age_eth[is.na(hh_type),c("hh_type","hh_type_fm","alone"):= #,"geoid" - maybe play with that later
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),
                                  list(alone)), on = .(bgHH_aet_match_id)]] #,list(geoid)
bgHH_type[is.na(age_eth_matched),c("age_eth_matched","HvL_ae","hh_age_range_3_ae"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(HvL),list(hh_age_range_3)), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth[is.na(hh_type)]) #176 left! - do the final match after race...
#fill out age_range_3_ae and HvL_ae, for comparison's sake
bgHH_type[,("HvL_ae"):=if_else(is.na(HvL_ae),HvL,HvL_ae)]
bgHH_type[,("hh_age_range_3_ae"):=if_else(is.na(hh_age_range_3_ae),hh_age_range_3,hh_age_range_3_ae)]
#family from this side is still imperfect...
#could make the HvL_ae move over the value of HvL that came from dec on type? Or just move straight from _dec... need to test
```

ground reference from doing it without doing the tract part first:
  table(bgHH_dec[HvL==TRUE,family])
   Family households Nonfamily households 
              462860               130822 
with seq.int:
table(bgHH_age_eth[,family])
   Family households Nonfamily households 
              569592                24090 
with sample:
table(bgHH_age_eth[,family])
   Family households Nonfamily households 
              426621               167061 
table(bgHH_age_eth[,family])
   Family households Nonfamily households 
              465514               128168  
which is a final difference of:
table(bgHH_dec[HvL==TRUE,family])-table(bgHH_age_eth[,family])
Family households        Nonfamily households 
               -2654                 2654 
and
table(bgHH_dec[HvL==TRUE,hh_type])#
Female householder, no spouse present              Householder living alone          Householder not living alone 
                               109604                                 96868                                 33954 
  Male householder, no spouse present                 Married couple family 
                                59919                                293337 
 table(bgHH_age_eth[,hh_type])
Female householder, no spouse present              Householder living alone          Householder not living alone 
                               109516                                130294                                 36767 
  Male householder, no spouse present                 Married couple family 
                                52832                                264273 
and with the tract level readings for family
table(bgHH_age_eth[,hh_type])
Female householder, no spouse present              Householder living alone          Householder not living alone 
                               121078                                 97318                                 31008 
  Male householder, no spouse present                 Married couple family 
                                58047                                286231 #
table(bgHH_dec[HvL==TRUE,hh_type])-table(bgHH_age_eth[,hh_type])
Female householder, no spouse present              Householder living alone          Householder not living alone 
                               -11474                                  -450                                  2946 
  Male householder, no spouse present                 Married couple family 
                                 1872                                  7106 
not perfect - really need to keep dec as base                                 
put race from dec on type, as a first approx
maybe that gives us a first match, and then we can do the second match with one less variable, like I used to??? or coming from a different set??

Try the same with race
```{r join bgHH_age_race to size, type, and dec}
#then do the match
#move the HvL race combinations from _dec back to age (and size) eth
bgHH_dec[,("bgHH_dret_match_id"):=
                    paste0(geoid,family,rent_own,hh_type,HvL,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,rent_own,hh_type,HvL,hh_age_range_3)]
bgHH_age_eth[,("bgHH_dret_match_id"):=
                    paste0(geoid,family,rent_own,hh_type,HvL,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,rent_own,hh_type,HvL,hh_age_range_3)]
bgHH_age_eth[,("race"):=
                 bgHH_dec[.SD, list(race), on = .(bgHH_dret_match_id)]]
bgHH_dec[,("matched_age_eth_race"):=
                 bgHH_age_eth[.SD, list(race), on = .(bgHH_dret_match_id)]]
nrow(bgHH_age_eth[is.na(race)]) #75051 / 13% not matched

#try without rent_own, hh_age_range_3, and hh_type since they came from type without HvL 
bgHH_dec[is.na(matched_age_eth_race),("bgHH_dre_match_id"):=
                    paste0(geoid,family,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,HvL)]
bgHH_age_eth[is.na(race),("bgHH_dre_match_id"):=
                    paste0(geoid,family,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,HvL)]
bgHH_age_eth[is.na(race),c("race","hh_type","hh_type_fm","alone"):= 
                 bgHH_dec[.SD, c(list(race),list(hh_type),
                                 list(hh_type_fm),list(alone)), on = .(bgHH_dre_match_id)]]
bgHH_dec[is.na(matched_age_eth_race),c("matched_age_eth_race","rent_own_ae","hh_age_range_3_ae"):=
                 bgHH_age_eth[.SD, c(list(race),list(rent_own),list(hh_age_range_3)), on = .(bgHH_dre_match_id)]]
nrow(bgHH_age_eth[is.na(race)]) #8566 / 1.4%
nrow(bgHH_dec[!is.na(matched_age_eth_race)])==nrow(bgHH_age_eth[!is.na(race)])
#last bit from _dec, with HvL only
bgHH_dec[is.na(matched_age_eth_race),("bgHH_dre_match_id"):=
                    paste0(geoid,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL)]
bgHH_age_eth[is.na(race),("bgHH_dre_match_id"):=
                    paste0(geoid,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL)]
bgHH_age_eth[is.na(race),c("race","hh_type","hh_type_fm","alone","family"):= 
                 bgHH_dec[.SD, c(list(race),list(hh_type),list(hh_type_fm),
                                 list(alone),list(family)), on = .(bgHH_dre_match_id)]]
bgHH_dec[is.na(matched_age_eth_race),c("matched_age_eth_race","rent_own_ae","hh_age_range_3_ae"):=
                 bgHH_age_eth[.SD, c(list(race),list(rent_own),list(hh_age_range_3)), on = .(bgHH_dre_match_id)]]
nrow(bgHH_age_eth[is.na(race)])==0
#change bgHH_dec rent_own_ae and hh_age_range_ae
bgHH_dec[,("rent_own_ae"):=if_else(is.na(rent_own_ae),rent_own,rent_own_ae)]
bgHH_dec[,("hh_age_range_3_ae"):=if_else(is.na(hh_age_range_3_ae),hh_age_range_3,hh_age_range_3_ae)] 

#test with rent_own_ae and hh_age_range_3_ae
test <- table(
  bgHH_age_eth[,geoid],
  bgHH_age_eth[,race],
  bgHH_age_eth[,hh_type],
  bgHH_age_eth[,rent_own],
  bgHH_age_eth[,hh_age_range_3],
  bgHH_age_eth[,family]
  )==
  table(bgHH_dec[HvL==TRUE,geoid],
        bgHH_dec[HvL==TRUE,race],
        bgHH_dec[HvL==TRUE,hh_type],
        bgHH_dec[HvL==TRUE,rent_own_ae],
        bgHH_dec[HvL==TRUE,hh_age_range_3_ae],
        bgHH_dec[HvL==TRUE,family]
        )
length(test[test==FALSE]) == 0

#get age_race matches with age_eth (dec)
#put tr family from size and bg hh_size onto bg_age_race, then do matching by subtraction of factors
bgHH_size_race[,("bgHH_asrr_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_age_race[,("bgHH_asrr_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_age_race[,c("hh_size","family"):=
                 bgHH_size_race[.SD, c(list(hh_size),list(family)), on = .(bgHH_asrr_match_id)]]
nrow(bgHH_age_race[is.na(family)]) == 0

#match on as many as possible
bgHH_age_race[,("bgHH_are_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_size,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_size,hh_age_range_3)]
bgHH_age_eth[,("bgHH_are_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_size,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_size,hh_age_range_3)]
bgHH_age_race[,c("HvL","hh_type","hh_type_fm","alone"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),
                                     list(alone)), on = .(bgHH_are_match_id)]]
bgHH_age_eth[,("matched_eth_race"):=
                 bgHH_age_race[.SD, list(race), on = .(bgHH_are_match_id)]]
nrow(bgHH_age_eth) - nrow(bgHH_age_race[!is.na(HvL)]) #148685 / 75% matched

#family and hh_size could be wrong by geoid, so try without 
bgHH_age_race[is.na(HvL),("bgHH_aref_match_id"):=
                    paste0(geoid,race,rent_own,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,hh_age_range_3)]
bgHH_age_eth[is.na(matched_eth_race),("bgHH_aref_match_id"):=
                    paste0(geoid,race,rent_own,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,hh_age_range_3)]
bgHH_age_race[is.na(HvL),c("HvL","hh_type","hh_type_fm","alone"):= 
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),
                                     list(alone)), on = .(bgHH_aref_match_id)]]
bgHH_age_eth[is.na(matched_eth_race),c("matched_eth_race","family_ar",
                                       "hh_size_ar"):= #eventually move back to _dec???
                 bgHH_age_race[.SD, c(list(race),list(family),list(hh_size)), 
                               on = .(bgHH_aref_match_id)]]
nrow(bgHH_age_eth) - nrow(bgHH_age_race[!is.na(HvL)]) #36879 / 6%

#hh_age_range_3 could be wrong in match coming from dec - let it not match, but don't change on age_race
bgHH_age_race[is.na(HvL),("bgHH_ref_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_age_eth[is.na(matched_eth_race),("bgHH_ref_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_age_race[is.na(HvL),c("HvL","hh_type","hh_type_fm","alone"):= 
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),
                                     list(alone)), on = .(bgHH_ref_match_id)]]
bgHH_age_eth[is.na(matched_eth_race),c("matched_eth_race","family_ar",
                                       "hh_size_ar","hh_age_range_3_ar"):=
                 bgHH_age_race[.SD, c(list(race),list(family),list(hh_size),
                                      list(hh_age_range_3)), on = .(bgHH_ref_match_id)]]
nrow(bgHH_age_eth) - nrow(bgHH_age_race[!is.na(HvL)]) #13,895

#then without rent_own, with assumption that the right matches were switched earlier and will wash out
bgHH_age_race[is.na(HvL),("bgHH_refl_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_age_eth[is.na(matched_eth_race),("bgHH_refl_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_age_race[is.na(HvL),c("HvL","hh_type","hh_type_fm","alone"):= 
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),
                                     list(alone)), 
                              on = .(bgHH_refl_match_id)]]
bgHH_age_eth[is.na(matched_eth_race),c("matched_eth_race","family_ar",
                                       "hh_size_ar","hh_age_range_3_ar","rent_own_ar"):=
                 bgHH_age_race[.SD, c(list(race),list(family),
                                      list(hh_size),list(hh_age_range_3),list(rent_own)), 
                               on = .(bgHH_refl_match_id)]]
nrow(bgHH_age_eth) - nrow(bgHH_age_race[!is.na(HvL)]) == 0
#move family_ar,hh_size_ar,hh_age_range_3_ar,rent_own_ar back to _dec
bgHH_age_eth[,("rent_own_ar"):=if_else(is.na(rent_own_ar),rent_own,rent_own_ar)]
bgHH_age_eth[,("hh_age_range_3_ar"):=if_else(is.na(hh_age_range_3_ar),hh_age_range_3,hh_age_range_3_ar)] 
bgHH_age_eth[,("family_ar"):=if_else(is.na(family_ar),family,family_ar)]
bgHH_age_eth[,("hh_size_ar"):=if_else(is.na(hh_size_ar),hh_size,hh_size_ar)] #not to move to dec...

#move the changed values on age_eth back to _dec before matching on race
bgHH_dec[,("bgHH_dret2_match_id"):=
                    paste0(geoid,race,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_type,HvL)]
bgHH_age_eth[,("bgHH_dret2_match_id"):=
                    paste0(geoid,race,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_type,HvL)]
bgHH_age_eth[,("race"):=
                 bgHH_dec[.SD, list(race), on = .(bgHH_dret2_match_id)]]
bgHH_dec[,c("matched_eth_race","hh_age_range_3_ar","rent_own_ar","family_ar"):=
                 bgHH_age_eth[.SD, c(list(race),list(hh_age_range_3_ae),
                                     list(rent_own_ar),list(family_ar)), 
                              on = .(bgHH_dret2_match_id)]]
nrow(bgHH_dec[!is.na(family_ar)])==nrow(bgHH_age_eth)

#move type to age_race 
bgHH_age_race[is.na(HvL),("bgHH_tare_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_age_range_3)]
bgHH_type[is.na(HvL),("bgHH_tare_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_age_range_3)]
bgHH_age_race[is.na(HvL),c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),
                                     list(alone)), on = .(bgHH_tare_match_id)]]
bgHH_type[is.na(HvL),("matched_type_race"):=
                 bgHH_age_race[.SD, list(race), on = .(bgHH_tare_match_id)]]
nrow(bgHH_age_race[is.na(hh_type)]) #103224 / 9%

#move size down to _dec (with HvL as one of the matches) - family might work at tract level, not geoid



#do rest of type on dec and moves size down from bgHH_size_race; rent_own might overwrite from age again
#and start testing on how it works around...


#DON'T NEED
#get all the way back up to bgHH_size_race in same way, so we're triangulating
bgHH_size_race[,("bgHH_sre_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_size,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_size)]
bgHH_age_eth[,("bgHH_sre_match_id"):=
                    paste0(geoid,race,rent_own,family,hh_size,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own,family,hh_size)]
bgHH_size_race[,c("HvL","hh_type","hh_type_fm","alone"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_sre_match_id)]]
bgHH_age_eth[,("matched_eth_size_race"):=
                 bgHH_size_race[.SD, list(race), on = .(bgHH_sre_match_id)]]
nrow(bgHH_age_eth)-nrow(bgHH_size_race[!is.na(HvL)]) #87905
#and without family or hh_size
bgHH_size_race[is.na(HvL),("bgHH_fsre_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_age_eth[is.na(matched_eth_size_race),("bgHH_fsre_match_id"):=
                    paste0(geoid,race,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,rent_own)]
bgHH_size_race[is.na(HvL),c("HvL","hh_type","hh_type_fm","alone"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_fsre_match_id)]]
bgHH_age_eth[is.na(matched_eth_size_race),("matched_eth_size_race"):=
                 bgHH_size_race[.SD, list(race), on = .(bgHH_fsre_match_id)]]
nrow(bgHH_age_eth)-nrow(bgHH_size_race[!is.na(HvL)]) #13895
#and just on race
bgHH_size_race[is.na(HvL),("bgHH_rfsre_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_age_eth[is.na(matched_eth_size_race),("bgHH_rfsre_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_size_race[is.na(HvL),c("HvL","hh_type","hh_type_fm","alone"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_rfsre_match_id)]]
bgHH_age_eth[is.na(matched_eth_size_race),("matched_eth_size_race"):=
                 bgHH_size_race[.SD, list(race), on = .(bgHH_rfsre_match_id)]]
nrow(bgHH_age_eth)-nrow(bgHH_size_race[!is.na(HvL)]) == 0


#UGH below
bgHH_age_race[,("bgHH_ars_match_id"):=
                    paste0(geoid,race,HvL,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,HvL,rent_own)]
bgHH_size_race[,("bgHH_ars_match_id"):=
                    paste0(geoid,race,HvL,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,HvL,rent_own)]
bgHH_age_race[,c("hh_size","family"):=
                 bgHH_size_race[.SD, c(list(hh_size),list(family)), on = .(bgHH_ars_match_id)]]
nrow(bgHH_age_race[is.na(hh_size)])==0 
nrow(bgHH_age_race[is.na(family)])==0
#move single family households over from type to age: 
bgHH_age_race[hh_size=="1-person household" & HvL==FALSE,("bgHH_art1_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_type[alone=="Living alone" & is.na(age_eth_matched),("bgHH_art1_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_age_race[hh_size=="1-person household" & HvL==FALSE,c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_art1_match_id)]]
bgHH_type[alone=="Living alone" & is.na(age_eth_matched),("age_race_matched"):=
                 bgHH_age_race[.SD, list(race), on = .(bgHH_art1_match_id)]]
nrow(bgHH_type[alone=="Living alone"])-nrow(bgHH_age_race[!is.na(hh_type)]) #for race, it should be close, here 94,502 matched
nrow(bgHH_size_eth[hh_size=="1-person household"])-nrow(bgHH_age_eth[!is.na(hh_type)])# 2309 not matched
#then the more than 1 person households
bgHH_age_eth[hh_size!="1-person household",("bgHH_aet_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_type[alone!="Living alone",("bgHH_aet_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family)]
bgHH_age_eth[hh_size!="1-person household",c("hh_type","hh_type_fm","alone"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone)), on = .(bgHH_aet_match_id)]]
bgHH_type[alone!="Living alone",("age_eth_matched"):=
                 bgHH_age_eth[.SD, list(HvL), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth)-nrow(bgHH_age_eth[!is.na(hh_type)]) #7893
#then by tract - but allowing the geoid to shift, since some of the mismatch came from that; will recapture ground geoid from dec, although family should be right and geoid should be better than just an approximation and should still work at tract in any case
bgHH_age_eth[is.na(hh_type),("bgHH_aet_match_id"):=
                    paste0(tract,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(tract,hh_age_range_3,rent_own)]
bgHH_type[is.na(age_eth_matched),("bgHH_aet_match_id"):=
                    paste0(tract,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(tract,hh_age_range_3,rent_own)]
bgHH_age_eth[is.na(hh_type),c("hh_type","hh_type_fm","alone","family"):= # ,"geoid"- maybe play with that later - lots of moving parts
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone),
                                  list(family)), on = .(bgHH_aet_match_id)]] #,list(geoid)
bgHH_type[is.na(age_eth_matched),("age_eth_matched"):=
                 bgHH_age_eth[.SD, list(HvL), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth)==nrow(bgHH_age_eth[!is.na(hh_type)])
nrow(bgHH_age_eth[is.na(hh_type)])==0 
#have to make sure bgHH_dec geoids are respected in end - family from this side is still imperfect...
test_geoid_dec_age <- table(bgHH_dec[HvL==TRUE,geoid],
                            bgHH_dec[HvL==TRUE,family]
                            )-
  table(bgHH_age_eth[,geoid],
        bgHH_age_eth[,family]
        )
length(test_geoid_dec_age[test_geoid_dec_age>0]) / length(test_geoid_dec_age) #43%
length(test_geoid_dec_age[test_geoid_dec_age>7]) / length(test_geoid_dec_age) #277 / 5%
#have to decide how to characterize test on subtraction, if you move geoid over on the tract match.... not sure what it misses but seems to get pretty close
#match bgHH_type1 to bgHH_age_eth, moving type and family to eth, but sampling on .N (not seq.int)
test_tract_dec_age <- table(bgHH_dec[HvL==TRUE,tract],
                            bgHH_dec[HvL==TRUE,family]
                            )-
  table(bgHH_age_eth[,tract],
        bgHH_age_eth[,family]
        )
#it still has quite a few mismatches - need to think through what happened.
length(test_tract_dec_age[test_tract_dec_age>0]) / length(test_tract_dec_age) #33%
length(test_tract_dec_age[test_tract_dec_age>7]) / length(test_tract_dec_age) #120 / 5%

#ground reference from doing it without doing the tract part first:
#  table(bgHH_dec[HvL==TRUE,family])
#   Family households Nonfamily households 
#              462860               130822 
#with seq.int:
#table(bgHH_age_eth[,family])
#   Family households Nonfamily households 
#              569592                24090 
#with sample:
#table(bgHH_age_eth[,family])
#   Family households Nonfamily households 
#              426621               167061 
#table(bgHH_age_eth[,family])
#   Family households Nonfamily households 
#              465356               128326 
#which is a final difference of:
#table(bgHH_dec[HvL==TRUE,family])-table(bgHH_age_eth[,family])
#Family households Nonfamily households 
 #               -2496                 2496 
#and
#table(bgHH_dec[HvL==TRUE,hh_type])
#
#Female householder, no spouse present              Householder living alone          Householder not living alone 
#                               109604                                 96868                                 33954 
#  Male householder, no spouse present                 Married couple family 
#                                59919                                293337 
#> table(bgHH_age_eth[,hh_type])
#
#Female householder, no spouse present              Householder living alone          Householder not living alone 
#                               109516                                130294                                 36767 
#  Male householder, no spouse present                 Married couple family 
#                                52832                                264273 
#and with the tract level readings for family
#table(bgHH_age_eth[,hh_type])
#Female householder, no spouse present              Householder living alone          Householder not living alone 
#                               121078                                 97318                                 31008 
#  Male householder, no spouse present                 Married couple family 
#                                58047                                286231 
#
#table(bgHH_dec[HvL==TRUE,hh_type])-table(bgHH_age_eth[,hh_type])
#Female householder, no spouse present              Householder living alone          Householder not living alone 
#                               -11474                                  -450                                  2946 
#  Male householder, no spouse present                 Married couple family 
#                                 1872                                  7106 
#not perfect - really need to keep dec as base                                 
                                 
#put race from dec on type, as a first approx
#maybe that gives us a first match, and then we can do the second match with one less variable, like I used to??? or coming from a different set??
```





```{r old matching - prob delete}


bgHH_age_eth[,("bgHH_ed_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_dec[,("bgHH_ed_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_age_eth[,("race"):=
                 bgHH_dec[.SD, list(race), on = .(bgHH_ed_match_id)]]
nrow(bgHH_age_eth[is.na(race)]) #31,403 #53,230 i.e., just over 10%, when not with tract drawn down
#so find the ones that weren't matched and move from dec to eth, since they were off by about 10% because of the earlier match
bgHH_dec[,("matched_ed"):=
                 bgHH_age_eth[.SD, list(race), on = .(bgHH_ed_match_id)]]
nrow(bgHH_dec[!is.na(matched_ed)])==nrow(bgHH_age_eth[!is.na(race)])
#and get last ones on age_eth that don't match 
bgHH_age_eth[is.na(race),("bgHH_ed1_match_id"):=
                    paste0(geoid,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL)]
bgHH_dec[is.na(matched_ed),("bgHH_ed1_match_id"):=
                    paste0(geoid,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,HvL)]
bgHH_age_eth[is.na(race),c("race","family","hh_type"):=
                 bgHH_dec[.SD, c(list(race),list(family),list(hh_type)), on = .(bgHH_ed1_match_id)]]
nrow(bgHH_age_eth[is.na(race)])==0
test <- table(bgHH_age_eth[,geoid],
              bgHH_age_eth[,family],
              bgHH_age_eth[,hh_type],
              bgHH_age_eth[,race],
              bgHH_age_eth[,HvL]
              )==
        table(bgHH_dec[HvL==TRUE,geoid],
              bgHH_dec[HvL==TRUE,family],
              bgHH_dec[HvL==TRUE,hh_type],
              bgHH_dec[HvL==TRUE,race],
              bgHH_dec[HvL==TRUE,HvL]
              )
length(test[test==FALSE])==0
```

ok - have to be smarter

```{r join bgHH_age_race to bgHH_type and dec}
#move the eth/race matches over to bgHH_type, so pulling properly
#type match was already done for the age_eth
#since 10% of age_eth was replaced from dec on family and type, we need to match again.

bgHH_age_eth[,("bgHH_aert_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,hh_type,hh_type_fm,alone,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family,hh_type,hh_type_fm,alone)]
bgHH_type[,("bgHH_aert_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,family,hh_type,hh_type_fm,alone,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,family,hh_type,hh_type_fm,alone)]
bgHH_type[,c("HvL","race"):=
                 bgHH_age_eth[.SD, c(list(HvL),list(race)), on = .(bgHH_aert_match_id)]]
nrow(bgHH_age_eth)-nrow(bgHH_type[!is.na(race)]) #2639, without hh_type_fm. 
#test

#add type and family to age_race [remember we're missing a few from eth; need to pick up at end]
#get HvL
bgHH_age_race[,("bgHH_rte_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,race)]
bgHH_type[HvL==TRUE,("bgHH_rte_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own,race)]
bgHH_age_race[,c("hh_type","family","HvL"):=
                 bgHH_type[.SD, c(list(hh_type),list(family),list(HvL)), on = .(bgHH_rte_match_id)]]
bgHH_type[HvL==TRUE,c("race","HvL"):=
                 bgHH_type[.SD, c(list(race),list(HvL)), on = .(bgHH_rte_match_id)]]
nrow(bgHH_age_race[!is.na(family)])-nrow(bgHH_age_eth) #missing 37800
#rest of type for race
bgHH_type[is.na(HvL),("HvL"):=FALSE]
bgHH_age_race[is.na(family),("bgHH_rt_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own)]
bgHH_type[HvL==FALSE,("bgHH_rt_match_id"):=
                    paste0(geoid,hh_age_range_3,rent_own,as.character(100000+sample(1:.N))),
                  by=.(geoid,hh_age_range_3,rent_own)]
bgHH_age_race[is.na(family),c("hh_type","hh_type_fm","alone","family"):=
                 bgHH_type[.SD, c(list(hh_type),list(hh_type_fm),list(alone),list(family)), on = .(bgHH_rt_match_id)]]
bgHH_type[HvL==FALSE,c("race","HvL"):=
                 bgHH_type[.SD, c(list(race),list(HvL)), on = .(bgHH_rt_match_id)]]
nrow(bgHH_age_race[is.na(family)]) #35614 unmatched!!! (about 2%)

#now get dec to nail it down - something is broken!!!!!!
bgHH_age_race[,("bgHH_tdr_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_dec[,("bgHH_tdr_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+sample(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_age_race[,c("hh_type","family"):=
                 bgHH_dec[.SD, c(list(hh_type),list(family)), on = .(bgHH_tdr_match_id)]]
nrow(bgHH_age_race[is.na(family)]) #ugh!! broken!!
#so find the ones that weren't matched and move from dec to eth, since they were off by about 10% because of the earlier match
bgHH_dec[,("matched_rd"):=
                 bgHH_age_race[.SD, list(race), on = .(bgHH_tdr_match_id)]]
nrow(bgHH_dec[!is.na(matched_rd)])==nrow(bgHH_age_race[!is.na(family)])
#and get last ones on age_eth that don't match 
bgHH_age_race[is.na(family),("bgHH_rd1_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_dec[is.na(matched_rd),("bgHH_rd1_match_id"):=
                    paste0(geoid,race,as.character(100000+sample(1:.N))),
                  by=.(geoid,race)]
bgHH_age_race[is.na(family),c("family","hh_type"):=
                 bgHH_dec[.SD, c(list(family),list(hh_type)), on = .(bgHH_rd1_match_id)]]
nrow(bgHH_age_eth[is.na(race)])==0
test <- table(bgHH_age_eth[,geoid],
              bgHH_age_eth[,family],
              bgHH_age_eth[,hh_type],
              bgHH_age_eth[,race],
              bgHH_age_eth[,HvL]
              )==
        table(bgHH_dec[HvL==TRUE,geoid],
              bgHH_dec[HvL==TRUE,family],
              bgHH_dec[HvL==TRUE,hh_type],
              bgHH_dec[HvL==TRUE,race],
              bgHH_dec[HvL==TRUE,HvL]
              )
length(test[test==FALSE])==0

#when add size, remember we know alone etc.

```

```{r old attempts}



#how well does it fit onto age_race?
bgHH_age_race1 <- rbindlist(list(bgHH_age_race,bgHH_age_race))
bgHH_age_eth[,("bgHH_aer_match_id"):=
                    paste0(geoid,race_tmp,hh_age_range,rent_own,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,race_tmp,hh_age_range,rent_own)]
bgHH_age_race1[,("bgHH_aer_match_id"):=
                    paste0(geoid,race,hh_age_range,rent_own,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,race,hh_age_range,rent_own)]
bgHH_age_race1[,("HvL_tmp"):=
                 bgHH_age_eth[.SD, list(HvL), on = .(bgHH_aer_match_id)]]
nrow(bgHH_age_race1[!is.na(HvL_tmp)])-nrow(bgHH_age_eth) 
#use age_race to reduce the size again, 



bgHH_age_race1a <- bgHH_age_race[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race1a[,("HvL"):=TRUE]
bgHH_age_race1b <- bgHH_age_race[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race1b[,("HvL"):=FALSE]
bgHH_age_race1 <- rbindlist(list(bgHH_age_race1a,bgHH_age_race1b))
bgHH_age_race1[,("bgHH_are_match_id"):=
                    paste0(geoid,hh_age_range,rent_own,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,hh_age_range,rent_own,HvL)]
bgHH_age_eth[,("HvL"):=TRUE]
bgHH_age_eth[,("bgHH_are_match_id"):=
                    paste0(geoid,hh_age_range,rent_own,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,hh_age_range,rent_own,HvL)]
bgHH_age_race1[,("matched_HvL"):=
                 bgHH_age_eth[.SD, list(HvL), on = .(bgHH_are_match_id)]]
nrow(bgHH_age_race1[!is.na(matched_HvL)])==nrow(bgHH_age_eth)

bgHH_dec[,("bgHH_ared_match_id"):=
                    paste0(geoid,race,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,race,HvL)]
bgHH_dec[,c("rent_own","hh_age_range","hh_age_range_3"):=
                    bgHH_age_race1[.SD, c(list(rent_own),list(hh_age_range),
                                          list(hh_age_range_3)), on = .(bgHH_ared_match_id)]]

#test
nrow(bgHH_dec[is.na(rent_own)])==0
test <- table(
  bgHH_age_race[,geoid],
  bgHH_age_race[,rent_own],
  bgHH_age_race[,hh_age_range],
  bgHH_age_race[,hh_age_range_3],
  bgHH_age_race[,race]
) == table(
  bgHH_dec[,geoid],
  bgHH_dec[,rent_own],
  bgHH_dec[,hh_age_range],
  bgHH_dec[,hh_age_range_3],
  bgHH_dec[,race]
)
length(test[test==FALSE])==0

#test against eth


bgHH_age_race1c[,("hh_age_race_family_HvL_id"):=hh_age_race_id+200000]

#expand by family already, since we don't know on it??
#expand cartesian product - easy by two, although 2x2 is 4
bgHH_age_race1a <- bgHH_age_race[rep(!is.na(geoid),2,length=.N),] #to make a copy that is separate and not a reference
bgHH_age_race1a[,("family"):="Family households"]
bgHH_age_race1a[,("hh_age_race_family_id"):=hh_age_race_id+100000]
bgHH_age_race1b <- bgHH_age_race[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race1b[,("family"):="Nonfamily households"]
bgHH_age_race1b[,("hh_age_race_family_id"):=hh_age_race_id+100000]
bgHH_age_race1a1 <- rbindlist(list(bgHH_age_race1a,bgHH_age_race1b))
bgHH_age_race1c <- bgHH_age_race1a1[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race1c[,("HvL"):=TRUE]
bgHH_age_race1c[,("hh_age_race_family_HvL_id"):=hh_age_race_id+200000]
bgHH_age_race1d <- bgHH_age_race1a1[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race1d[,("HvL"):=FALSE]
bgHH_age_race1d[,("hh_age_race_family_HvL_id"):=hh_age_race_id+200000]
bgHH_age_race1 <- rbindlist(list(bgHH_age_race1c,bgHH_age_race1d)) 
#can we add something here that drives it back down to a smaller space without losing structure?
#by looking for the intersection of the cartesian expanded, we should get smaller space
bgHH_age_eth1a <- bgHH_age_eth[rep(!is.na(geoid),2,length=.N),] #to make a copy that is separate and not a reference
bgHH_age_eth1a[,("family"):="Family households"]
bgHH_age_eth1a[,("hh_age_eth_family_id"):=hh_age_eth_id+100000]
bgHH_age_eth1b <- bgHH_age_eth[rep(!is.na(geoid),2,length=.N),]
bgHH_age_eth1b[,("family"):="Nonfamily households"]
bgHH_age_eth1b[,("hh_age_eth_family_id"):=hh_age_eth_id+100000]
bgHH_age_eth1 <- rbindlist(list(bgHH_age_eth1a,bgHH_age_eth1b))
bgHH_age_eth1[,("HvL"):=TRUE]
bgHH_age_race1[,("bgHH_are_match_id"):=
                    paste0(geoid,family,rent_own,hh_age_range_3,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,rent_own,hh_age_range_3,HvL)]
bgHH_age_eth1[,("bgHH_are_match_id"):=
                    paste0(geoid,family,rent_own,hh_age_range_3,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,rent_own,hh_age_range_3,HvL)]
bgHH_age_race1[,("matched_are"):=
                    bgHH_age_eth1[.SD, list(family), on = .(bgHH_are_match_id)]]
bgHH_age_race2 <- bgHH_age_race1[!is.na(matched_are) | HvL == FALSE] #should get rid of ones that can't match
rm(list=ls(pattern=("bgHH_age_race1")))
rm(list=ls(pattern=("bgHH_age_eth1")))
bgHH_age_race3a <- bgHH_age_race2[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race3a[,("hh_type"):="Female householder, no spouse present"]
bgHH_age_race3b <- bgHH_age_race2[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race3b[,("hh_type"):="Male householder, no spouse present"]
bgHH_age_race3c <- bgHH_age_race2[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race3c[,("hh_type"):="Householder living alone"]
bgHH_age_race3d <- bgHH_age_race2[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race3d[,("hh_type"):="Married couple family"]
bgHH_age_race3e <- bgHH_age_race2[rep(!is.na(geoid),2,length=.N),]
bgHH_age_race3e[,("hh_type"):="Householder not living alone"]
bgHH_age_race3 <- rbindlist(list(bgHH_age_race3a,bgHH_age_race3b,bgHH_age_race3c,bgHH_age_race3d,bgHH_age_race3e))
bgHH_age_race3[,("bgHH_taer_match_id"):=
                    paste0(geoid,family,rent_own,hh_age_range_3,race,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,rent_own,hh_age_range_3,race,HvL)]
#do cartesian product on race/eth for bgHH_type
bgHH_type1a <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1a[,("race"):="A"]
bgHH_type1b <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1b[,("race"):="B"]
bgHH_type1c <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1c[,("race"):="C"]
bgHH_type1d <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1d[,("race"):="D"]
bgHH_type1e <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1e[,("race"):="E"]
bgHH_type1f <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1f[,("race"):="F"]
bgHH_type1g <- bgHH_type[rep(!is.na(geoid),2,length=.N),] 
bgHH_type1g[,("race"):="G"]
bgHH_type1HvL <- rbindlist(list(bgHH_type1a,bgHH_type1b,bgHH_type1c,bgHH_type1d,bgHH_type1e,bgHH_type1f,bgHH_type1g))
bgHH_type1HvL[,("HvL"):=TRUE]
bgHH_type1r <- rbindlist(list(bgHH_type1a,bgHH_type1b,bgHH_type1c,bgHH_type1d,bgHH_type1e,bgHH_type1f,bgHH_type1g)) 
bgHH_type1r[,("HvL"):=FALSE]
bgHH_type1 <- rbindlist(list(bgHH_type1r,bgHH_type1HvL))
bgHH_type1[,("bgHH_taer_match_id"):=
                    paste0(geoid,family,rent_own,hh_age_range_3,race,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,rent_own,hh_age_range_3,race,HvL)]
bgHH_type1[,c("hh_age_range","hh_age_range_3","hh_age_race_family_id"):=
                    bgHH_age_race3[.SD, c(list(hh_age_range),list(hh_age_range_3),
                                          list(hh_age_race_family_id)), on = .(bgHH_taer_match_id)]]
bgHH_age_race3[,c("matched","hh_type"):=
                    bgHH_type1[.SD, c(list(race),list(hh_type)), on = .(bgHH_taer_match_id)]]
#do tests to just make sure basic steps are being performed
nrow(bgHH_age_race3[!is.na(matched)])==nrow(bgHH_type1[!is.na(hh_age_range)])
#tests
test <- table(
  bgHH_type1[!is.na(hh_age_range),geoid],
  bgHH_type1[!is.na(hh_age_range),family],
  bgHH_type1[!is.na(hh_age_range),rent_own],
  bgHH_type1[!is.na(hh_age_range),hh_age_range],
  bgHH_type1[!is.na(hh_age_range),hh_age_range_3],
  bgHH_type1[!is.na(hh_age_range),race],
  bgHH_type1[!is.na(hh_age_range),HvL]
) == table(
  bgHH_age_race3[!is.na(matched),geoid],
  bgHH_age_race3[!is.na(matched),family],
  bgHH_age_race3[!is.na(matched),rent_own],
  bgHH_age_race3[!is.na(matched),hh_age_range],
  bgHH_age_race3[!is.na(matched),hh_age_range_3],
  bgHH_age_race3[!is.na(matched),race],
  bgHH_age_race3[!is.na(matched),HvL]
)
length(test[test==FALSE])==0

bgHH_type2 <- bgHH_type1[!is.na(hh_age_range)]

#expand bgHH_dec for three age ranges to match
bgHH_dec1a <- bgHH_dec[rep(!is.na(geoid),2,length=.N),] 
bgHH_dec1a[,("hh_age_range_3"):="Householder 15 to 34 years"]
bgHH_dec1b <- bgHH_dec[rep(!is.na(geoid),2,length=.N),] 
bgHH_dec1b[,("hh_age_range_3"):="Householder 35 to 64 years"]
bgHH_dec1c <- bgHH_dec[rep(!is.na(geoid),2,length=.N),] 
bgHH_dec1c[,("hh_age_range_3"):="Householder 65 years and over"]
bgHH_dec1 <- rbindlist(list(bgHH_dec1a,bgHH_dec1b,bgHH_dec1c))


bgHH_dec1[,("bgHH_ftra_match_id"):=
                    paste0(geoid,family,hh_type,race,HvL,hh_age_range_3,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,race,HvL,hh_age_range_3)]
bgHH_type2 <- bgHH_type2[order(hh_age_race_family_id)]
bgHH_type2[,("bgHH_ftra_match_id"):=
                    paste0(geoid,family,hh_type,race,HvL,hh_age_range_3,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,race,HvL,hh_age_range_3)]
bgHH_dec1[,c("rent_own","hh_age_range","hh_age_range_3"):=
                    bgHH_type2[.SD, c(list(rent_own),list(hh_age_range),list(hh_age_range_3)), on = .(bgHH_ftra_match_id)]]
bgHH_type2[,("matched2"):=
                    bgHH_dec1[.SD, list(re_code), on = .(bgHH_ftra_match_id)]]

nrow(bgHH_type)==nrow(bgHH_dec1[!is.na(rent_own)])

test <- table(
  bgHH_type2[!is.na(matched2),geoid],
  bgHH_type2[!is.na(matched2),rent_own],
  bgHH_type2[!is.na(matched2),family],
  bgHH_type2[!is.na(matched2),hh_type]
) == table(
  bgHH_dec1[!is.na(rent_own),geoid],
  bgHH_dec1[!is.na(rent_own),rent_own],
  bgHH_dec1[!is.na(rent_own),family],
  bgHH_dec1[!is.na(rent_own),hh_type]
)
length(test[test==FALSE])==0

#pull dec1 back down to dec???
bgHH_dec1[,("bgHH_dec_match_id"):=
                    paste0(geoid,family,hh_type,race,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,race,HvL)]
bgHH_dec[,("bgHH_dec_match_id"):=
                    paste0(geoid,family,hh_type,race,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,race,HvL)]
bgHH_dec[,c("reduced_match","rent_own"):=
                    bgHH_dec1[.SD, c(list(race),list(rent_own)), on = .(bgHH_dec_match_id)]]
nrow(bgHH_dec[is.na(reduced_match)])==0

test <- table(
  bgHH_type[,geoid],
  #bgHH_type[,rent_own],
  bgHH_type[,family],
  bgHH_type[,hh_type]
) == table(
  bgHH_dec[,geoid],
  #bgHH_dec[,rent_own],
  bgHH_dec[,family],
  bgHH_dec[,hh_type]
)
length(test[test==FALSE])==0

#bgHH_type1a <- rbindlist(list(bgHH_type1,bgHH_type[rep(HvL==FALSE,2,length=.N),])) 
#bgHH_type1b <- rbindlist(list(bgHH_type1a,bgHH_type[rep(rent_own=="Renter occupied",2,length=.N),])) 
#bgHH_type1c <- rbindlist(list(bgHH_type1b,bgHH_type[rep(rent_own=="Owner occupied",2,length=.N),])) 
#bgHH_type1d <- rbindlist(list(bgHH_type1c,bgHH_type[rep(hh_age_range_3=="Householder 15 to 34 years",2,length=.N),]))
#bgHH_type1e <- rbindlist(list(bgHH_type1d,bgHH_type[rep(hh_age_range_3=="Householder 65 years and over",2,length=.N),]))
#bgHH_type2 <- rbindlist(list(bgHH_type1e,bgHH_type[rep(hh_age_range_3=="Householder 35 to 64 years",2,length=.N),]))
#it has to be that some aren't matching because of the .N part of the counting, since it works by the not expanded

```


```{r join bgHH_age to bgHH_type on rent_own and age_range_3}
#do the naive match, but eth first
bgHH_age_eth[,("bgHH_aet_match_id"):=
                    paste0(geoid,rent_own,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,rent_own,hh_age_range_3)]
bgHH_type[,("bgHH_aet_match_id"):=
                    paste0(geoid,rent_own,hh_age_range_3,as.character(100000+sample(1:.N))),
                  by=.(geoid,rent_own,hh_age_range_3)]
bgHH_type[,("HvL"):=
                    bgHH_age_eth[.SD, list(HvL), on = .(bgHH_aet_match_id)]]
nrow(bgHH_age_eth)==nrow(bgHH_type[!is.na(HvL)])
bgHH_type[is.na(HvL),("HvL"):=FALSE]

test <- table(
  bgHH_type[HvL==TRUE,geoid],
  bgHH_type[HvL==TRUE,rent_own],
  bgHH_type[HvL==TRUE,hh_age_range_3],
  bgHH_type[HvL==TRUE,HvL]
) == table(
  bgHH_age_eth[,geoid],
  bgHH_age_eth[,rent_own],
  bgHH_age_eth[,hh_age_range_3],
  bgHH_age_eth[,HvL]
)
length(test[test==FALSE])==0

#add race from bgHH_dec on family, hh_type and HvL - add the amount that didn't match by duplicating categories???
#what if we just doubled the size of the folks that have HvL == TRUE
#point is that each row that is HvL either should have been or should not have been, but that a bunch are now seen as only being possibly not and thus are excluded. Once larger for HvL and once larger for rent_own?
#this made it worse! with only one, it actually matched better!!
bgHH_type1 <- rbindlist(list(bgHH_type,bgHH_type[rep(HvL==TRUE,2,length=.N),])) 
bgHH_type1a <- rbindlist(list(bgHH_type1,bgHH_type[rep(HvL==FALSE,2,length=.N),])) 
bgHH_type1b <- rbindlist(list(bgHH_type1a,bgHH_type[rep(rent_own=="Renter occupied",2,length=.N),])) 
bgHH_type1c <- rbindlist(list(bgHH_type1b,bgHH_type[rep(rent_own=="Owner occupied",2,length=.N),])) 
bgHH_type1d <- rbindlist(list(bgHH_type1c,bgHH_type[rep(hh_age_range_3=="Householder 15 to 34 years",2,length=.N),]))
bgHH_type1e <- rbindlist(list(bgHH_type1d,bgHH_type[rep(hh_age_range_3=="Householder 65 years and over",2,length=.N),]))
bgHH_type2 <- rbindlist(list(bgHH_type1e,bgHH_type[rep(hh_age_range_3=="Householder 35 to 64 years",2,length=.N),]))
#it has to be that some aren't matching because of the .N part of the counting, since it works by the not expanded
bgHH_dec[,("bgHH_ft_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_type2[,("bgHH_ft_match_id"):=
                    paste0(geoid,family,hh_type,HvL,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,hh_type,HvL)]
bgHH_type2[,("race"):=
                    bgHH_dec[.SD, list(race), on = .(bgHH_ft_match_id)]]
bgHH_type3 <- bgHH_type2[!is.na(race)]

#then repeat taking race and age_range down to bgHH_type, but matching on race, too!



test <- table(
  bgHH_type[is.na(HvL),geoid],
  bgHH_type[is.na(HvL),rent_own],
  bgHH_type[is.na(HvL),hh_age_range_3],
  bgHH_type[is.na(HvL),HvL]
) == table(
  bgHH_age_eth[,geoid],
  bgHH_age_eth[,rent_own],
  bgHH_age_eth[,hh_age_range_3],
  bgHH_age_eth[,HvL]
)
length(test[test==FALSE])==0


```

```{r join bgHH_size to bgHH_dec on family and hh_type}
```


```{r join bgHH_type to bgHH_dec on family and hh_type}
```

#some tests
```{r checking for best fit}
bg_gq_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P5",county_num = county,
                         block="block_group",api_type="dec/pl",path_suff="est.csv")
bg_gq_data <- as.data.table(bg_gq_data_from_census)
bg_gq_data[,4:ncol(bg_gq_data)] <- 
  bg_gq_data[,lapply(.SD[,4:ncol(bg_gq_data)], as.numeric)]
rm(bg_gq_data_from_census)

tr_hh_own_children_tenure_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "HCT2",county_num = "*",
                         block="tract",api_type="dec/dhc",path_suff="est.csv")
#and PCT8 RELATIONSHIP BY AGE FOR THE POPULATION UNDER 18 YEARS
#5
bg_hh_own_children_type_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P20",county_num = "*",
                         block="block_group",api_type="dec/dhc",path_suff="est.csv")

tr_hh_tenure_children_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "HCT3",county_num = "*",
                         block="tract",api_type="dec/dhc",path_suff="est.csv")
#6
bg_hh_family_children_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P21",county_num = "*",
                         block="block_group",api_type="dec/dhc",path_suff="est.csv")

#no bg available - odd collection of kinda everything, percent and count...
tr_dp_relationship_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "DP1",county_num = "*",
                         block="tract",api_type="dec/dp",path_suff="est.csv")

bg_hh_type_relation_data_from_census <-  #seems to have all the categories of PCT17, which also has race/ethnicity...
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P17",county_num = "*",
                         block="block_group",api_type="dec/dhc",path_suff="est.csv")

tr_hh_type_relation_race_data_from_census <-  #seems to have all the categories of PCT17, which also has race/ethnicity...
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "PCT17",county_num = "*",
                         block="tract",api_type="dec/dhc",path_suff="est.csv")

#nothing here that isn't in bgHH_type
#tr_hh_type_age_data_from_census <- 
#  censusData_byGroupName(censusdir, vintage, state, censuskey, 
#                         groupname = "PCT3",county_num = "*",
#                         block="tract",api_type="dec/dhc",path_suff="est.csv")
#
#and PCT9 HOUSEHOLD TYPE BY RELATIONSHIP FOR THE POPULATION 65 YEARS AND OVER
#should use this!! has race/eth as well as details on pop over 65 - but not just householders... might have to use it twice
tr_hh_type_rel_seniors_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "PCT9",county_num = "*",
                         block="tract",api_type="dec/dhc",path_suff="est.csv")

#PCT15 is coupled households, including same sex
tr_hh_couples_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "PCT15",county_num = "*",
                         block="tract",api_type="dec/dhc",path_suff="est.csv")

#PCT12 and 13 give sex by age in hh and total, so could deduce others... but at tract level

bg_gq_age_data_from_census <- 
  censusData_byGroupName(censusdir, vintage, state, censuskey, 
                         groupname = "P18",county_num = "*",
                         block="block_group",api_type="dec/dhc",path_suff="est.csv")

#has no group name but is more than 25 variables - have to just put in the one variable
#response_data_from_census <- 
#  censusData_byGroupName(censusdir, vintage, state, censuskey, 
#                         groupname = "",county_num = "*",
#                         block="tract",api_type="dec/responserate",path_suff="est.csv")
#this gets "name":"CRRALL","label":"Cumulative Self-Response Rate - Overall"
response_data_from_census <- getCensus(name = "dec/responserate",
                                         vintage = vintage,
                                         vars = c("NAME", "CRRALL"),
                                         region = region, 
                                         regionin = regionin,
                                         key = censuskey)
#and https://api.census.gov/data/2020/dec/pes/variables.html for other alternatives on expanding...
```

#ADD HOUSEHOLDS AND GROUP QUARTERS

[[longer conversation about what it means to understand this as a problem with finding the right unit for analysis - either the individual or the relations; can this use that distinction between building from the inside (set theory) and from the outside (type theory)?; that we can look to the 'empty' representation that only has the bear counts of SARE at the block group, and then have it carry some information about that geography that trumps our expectations but still has to mesh with the counts that come from other subsetting moves - in fact, and maybe from the beginning, this is where you're not really subsetting, but sub-typing; types are propositions... in any set of claims, not just abstract logical principles. Does thinking about the poset as a product and as therefore having an adjoint give us a way of understanding why "ordering" the two sides and then matching makes sense??]]

#Plan for rest of matches for households and group quarters.
[need to do]

SARE tract level for households does not have all the ethnicities that SARE for individuals had - just more breakdowns (23 groups) in age and H,I in ethnicity at the tract level; since we've already done the match on bgSAE, though, we can be sure that we can get the right matches. We'll want to add it to as much information as we can get from the Group Quarters, first, so that the extra information on that side isn't obscured. 

We'll also want to make sure to not move to matching at the tract level too quickly, because we want to conserve that tract level matching when assigning block level matches and there are possible ways to introduce non-commutative relations - for example, by having non-White HvL in the wrong block for households and then not having that category given for group quarters and so having a mis-assignment.

What we'll do, therefore, is move the tract level information from bgSAR to the tract level on HH_SARE, since no information is lost that way, and then we'll do refinements from that side, before moving back to the bgSAR and making assignments - to the best of our ability! some information was not given - at the block level.

```{r download household family SARE tract}
trHH_SARE_data_from_census <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "PCT13",county_num = county,
                         block="tract",api_type="dec/sf1",path_suff="est.csv")
trHH_SARE_data <- as.data.table(trHH_SARE_data_from_census)
trHH_SARE_data[,4:ncol(trHH_SARE_data)] <- 
  trHH_SARE_data[,lapply(.SD[,4:ncol(trHH_SARE_data)], as.numeric)]
rm(trHH_SARE_data_from_census)
```

Then do our basic checks: 
```{r household own kids race / ethnicity age test problems}
check_summary <- census_table_check(trHH_SARE_data[!str_detect(concept,"HISPANIC")], 
      "SEX BY AGE FOR THE POPULATION IN HOUSEHOLDS","individuals in state") 
cat(check_summary[1])
```

```{r expand family SARE tract, warning = FALSE}
race_codes <- c("A","B","C","D","E","F","G")
trHHr <- trHH_SARE_data %>%
  pivot_longer(4:ncol(trHH_SARE_data),names_to = "tract", values_to = "number_sams") %>% 
  filter(substr(tract,3,5)==county) %>% #only Harris County
  mutate(
    race = substr(name,7,7),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("sex","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  #using the beg/end_age_P22, since they match.
  mutate(age_range = str_replace_all(age_range,"and","to"),
         age_range = str_replace_all(age_range,"85","85 to 110"),
         age_range = str_replace_all(age_range,"Under 5","0  to 05"),
         age_range = str_replace_all(age_range,"5 to 9","05 to 09"),
         age_range = str_replace_all(age_range,"20 years","20 to 20"),
         age_range = str_replace_all(age_range,"21 years","21 to 21"),
         first_age = as.numeric(substr(age_range,1,2)),
         last_age = as.numeric(substr(age_range,7,9))) %>%
  filter(!is.na(age_range) & race%in%race_codes) %>% #to get rid of aggregations by family
  uncount(number_sams,.id = "hhr_tr_SARE_id",.remove = TRUE) 
trHHr <- as.data.table(trHHr) #dyplyr had stripped it of dt
paste0("Number of individuals in households by race: ", nrow(trHHr))

#and same for ethnicity
trHHe <- trHH_SARE_data %>%
  pivot_longer(4:ncol(trHH_SARE_data),names_to = "tract", values_to = "number_sams") %>% 
  filter(substr(tract,3,5)==county) %>% #only Harris County
  mutate(
    ethnicity = substr(name,7,7),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("sex","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  #using the beg/end_age_P22, since they match.
  mutate(age_range = str_replace_all(age_range,"and","to"),
         age_range = str_replace_all(age_range,"85","85 to 110"),
         age_range = str_replace_all(age_range,"Under 5","0  to 05"),
         age_range = str_replace_all(age_range,"5 to 9","05 to 09"),
         age_range = str_replace_all(age_range,"20 years","20 to 20"),
         age_range = str_replace_all(age_range,"21 years","21 to 21"),
         first_age = as.numeric(substr(age_range,1,2)),
         last_age = as.numeric(substr(age_range,7,9))) %>%
  filter(!is.na(age_range) & ethnicity%in%c("H","I")) %>% #to get rid of aggregations by family
  uncount(number_sams,.id = "hhe_tr_SARE_id",.remove = TRUE) 
trHHe <- as.data.table(trHHe) 
paste0("Number of individuals in households by ethnicity: ", nrow(trHHe))
#ensure age_range matches
test <- unique(trHHe[order(age_range),age_range])==
  unique(trHHr[order(age_range),age_range])
length(test[test==FALSE])==0
rm(trHH_SARE_data)
```

Let's do a couple of quick tests to make sure that the overall approach will work. We're assuming that there are a determined set of individual rows, of which some portion is the population living in households, and that the tables representing characteristics of those individuals all refer back to the same overall representation in terms of those rows. Let's just make sure that the counts per cell are less for all our relevant combinations in the household tables than in the overall.

Later, we'll match with the block group; the remainder between those in households and the whole population (by the rules of the construction and the disjunctive syllogism) should be those in group quarters, but we'll also take some steps to ensure that we haven't accidentally misattributed cases. In particular, we don't want to lose any of the fine-grained information on race and ethnicity combined at the tract level, or the greater geographic specificity available for all demographics at the block level for the total population table (bgSAR). The only race category that is completely exhausted by the ethnicity categories given in the household population tables is White, and so we go ahead and match them, with those in the Hispanic non-white remaining to be counted and distributed more carefully, below.

```{r join trHHr and trHHe for White non-Hispanic}

```

By the rules as we understand them, all individuals with race of "White Alone" are either Hispanic or not, but let's check that and use it to also give us some sense of a new method we will use to assign a specific number to missing categories, and then use that ordering within our types to make more detailed assignations. We will try to create an expanded table that includes as much information as possible about the individuals in households and group quarters, including the number of individuals in categories that we don't yet know how to assign, and then join with the block group information for all individuals. Talk a bit about the conservation of structure in terms of relation as a problem of well-ordered sets and the construction of the domains within which things are determined - building from outside in and not from inside out.

Although we know enough to fill in for the rest of the race=="A" (White) population, we want to create matching ids with an if clause that changes if the number is larger than the available designations in that category. We're testing the approach, and will later use it in places where we can't test it on individual steps (but can confirm whether it worked as a composite of steps). There are some complexities, here, that will pay off later as we think more carefully about what it means to have order conserved across table representations.

```{r count of ethnicity on trHHe and trHHr to determine non-White remainder}
#also put a temporary variable in place to see if it's the same thing as just having placed the designation directly
trHHr[race=="A"&is.na(ethnicity),("ethnicity_check"):="H"]
#but we want to mark the ones in trHHe, so we know which ones to eliminate (although an anti-join should also work)
trHHr[race=="A"&is.na(ethnicity),("trHHsae2_match_id"):=paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHe[ethnicity=="H",("trHHsae2_match_id"):=
                    paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHr[race=="A"&is.na(ethnicity),("ethnicity"):=
                    trHHe[.SD, list(ethnicity), on = .(trHHsae2_match_id)]]
trHHe[ethnicity=="H",("marked_r"):=
                    trHHr[.SD, list(race), on = .(trHHsae2_match_id)]]
#test to see whether race=="A"&ethnicity!="I" tables are equal on tract,sex,age_range with ethnicity=="H"
nrow(trHHr[race=="A"])-nrow(trHHr[ethnicity=="I"])==nrow(trHHr[ethnicity=="H"])
nrow(trHHe[!is.na(marked_r)])==nrow(trHHr[ethnicity=="H"])

nrow(trHHr[!is.na(ethnicity_check)])
test <- table(trHHr[race=="A"&ethnicity!="I",tract],
              trHHr[race=="A"&ethnicity!="I",sex],
              trHHr[race=="A"&ethnicity!="I",age_range],
              trHHr[race=="A"&ethnicity!="I",ethnicity_check]
) == table(
  trHHr[ethnicity=="H",tract],
  trHHr[ethnicity=="H",sex],
  trHHr[ethnicity=="H",age_range],
  trHHr[ethnicity=="H",ethnicity]
)
length(test[test==FALSE])==0
test <- table(trHHr[ethnicity=="I",tract],
              trHHr[ethnicity=="I",sex],
              trHHr[ethnicity=="I",age_range]
) == table(
  trHHe[ethnicity=="I",tract],
  trHHe[ethnicity=="I",sex],
  trHHe[ethnicity=="I",age_range]
)
length(test[test==FALSE])==0
trHHr$ethnicity_check <- NULL
```

The difference between the number of individuals in households and the number overall is only about 1% of the population - it's the people who are in so-called "group quarters," and includes different types of institutionalized settings, from college dorms to nursing homes to prisons. They are a small portion of the whole, and even within that small subset, there is enormous diversity, but they include some of the most vulnerable and important populations from the perspective of public health. 

#Build block group group quarters with age_ranges and then right join to hh - then match the things most known first.

For the household data, we don't have anything that tells us which block they're in yet, although we do have a great deal of block group level data that we'll incorporate in making_sam_hh.Rmd, but it is mostly for the head of household and not for the entire household. Here we want to show how to use the known structure from the block group level sex, age, race, and ethnicity to create a better representation of the households. Since we don't want to create structures that aren't justified by a known relation, we'll create counts for subgroups to use for the matching. So that those counts will be correct at the tract level, we'll need to add the group quarters to the households. To do that, first, we'll add rows to the household population data using only those facts we're sure of, with the other tables helping us add determination. Remember that we know the combination of race and ethnicity for every individual without any loss at the tract level, and only have worries about some of the combinations of non-White and Hispanic or Latino at the block level. We'll use that fact to grow the household table appropriately. Mostly, "appropriately" here means only that we aren't accidentally adding extra structure without warrant; we want to begin, at least, asking strictly mathematical questions about what we can do, given that the political questions about naming are given, at least for the present context. We can approach the mathematics by thinking of both tables as ordered sets, and then adding to the household table the number of rows needed to finish out the rows by sex, age, race, and ethnicity in each tract by group quarters. The group quarters tables includes some information about the block group structure that may also help, so we'll want to include it before distributing the household information to the total population. But let's create a workspace where we allow the characteristics we don't know to vary while securing the traits we do know into place in the table. We know that the information on the tract, race, and ethnicity is complete for the White population, and that the ordering we have for the block level by those same variables is complete - so no information will be lost by matching to the block level for that subgroup.   

If there are 2 people with same demographics in different block_groups, which one is assigned to the household population and which one to group quarters? That asks the question backwards in some sense. What we're really saying is that given that within each tract, a certain number of each type is to be distributed, are all the distributions fully determined? If so, then the block_groups will be correctly distributed. For example, if we have two persons who are identified as "White Alone, Not Hispanic or Latino," "Female," and age of "10 to 14 years," in two different block groups in a single tract in the block groups file and one person identified that way in the household file, there's no way to know which one should be labeled as being in the household and which one in group quarters. We do know some limited things about the distribution of group quarters, however, and let's try to use that to narrow down the issues. It's really a matter of channeling the distribution into more fully delimited paths, until the underlying structures are as conserved as possible.

```{r bring back bgSARE}
if(file.exists(paste0(censusdir,vintage,"/working/bgSARE.RDS"))){
  bgSARE <- readRDS(paste0(censusdir,vintage,"/working/bgSARE.RDS"))
}else{
  print("no bgSARE file found")
}
#change race to match race_descriptions
colnames(bgSARE)[colnames(bgSARE) == "race"] <- "race_description_HvL"
```

```{r determine size of mismatch across block groups}
#block_group/tract sex, age, race, and ethnicity = bg_sare/tr_sare 
bgSAR[,("eth2"):=if_else(ethnicity%in%c("H","I"),ethnicity,"not_known")]
trHHr[,("eth2"):=if_else(ethnicity%in%c("H","I"),ethnicity,"not_known")] #this will have all not A as not_known
trHHr[,("tr_sare"):=.N,by=.(tract,sex,first_age,race,eth2)]#only complete for race=="A"
trHHe[,("tr_sae"):=.N,by=.(tract,sex,first_age,ethnicity)] #only "H" and "I" 
trHHe[,("eth2"):=ethnicity]
trHHr[,("tr_sae_hh_match_id"):=
    paste0(tract,sex,first_age,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,eth2)]
trHHe[,("tr_sae_hh_match_id"):=
    paste0(tract,sex,first_age,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,eth2)]
trHHr[,("tr_sae"):=trHHe[.SD,list(tr_sae),on=.(tr_sae_hh_match_id)]]
trHHe[,("race"):=trHHr[.SD,list(race),on=.(tr_sae_hh_match_id)]]
trHHe[,("eth2"):=if_else(is.na(race),"not_known",eth2)]
trHHr[eth2=="not_known",("tr_sae_hh_match2_id"):=
    paste0(tract,sex,first_age,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,eth2)]
trHHe[eth2=="not_known",("tr_sae_hh_match2_id"):=
    paste0(tract,sex,first_age,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,eth2)]
trHHr[eth2=="not_known",("tr_sae"):=trHHe[.SD,list(tr_sae),on=.(tr_sae_hh_match2_id)]]
#add the number still needed to fill out H, not White
#trHHr[,("tr_sare"):=if_else(race!="A",tr_sare+tr_sae,tr_sare)]#creates na's at race=="A"??
trHHr[is.na(tr_sae),("tr_sae"):=0]
trHHr[,("tr_sare"):=tr_sare+tr_sae] #this just gives a magnitude for ordering
summary(trHHr[,tr_sare])
table(trHHr[tr_sare<11,tr_sare])
paste0("There are ",2*23*3*7," different possible combinations of sex, age, race, and ethnicity in each tract.")
paste0("Which, by the ",length(unique(trHHr$tract))," tracts would make: ",
       length(table(trHHr$tract,trHHr$sex,trHHr$first_age,trHHr$race,trHHr$eth2))," combinations.")
cellnum <- table(trHHr$tract,trHHr$sex,trHHr$first_age,trHHr$race,trHHr$eth2)
paste0("However, ",length(cellnum[cellnum==0])," have zero in the cell count (",
       as.integer(length(cellnum[cellnum==0])/length(cellnum)*100),"%)")

bgSAR[,("bg_sare"):=.N,by=.(geoid,sex,first_age,re_code,eth2)]
bgSAR[,("tr_sare"):=.N,by=.(tract,sex,first_age,re_code,eth2)]
#for each sare combo, rank how many in each block - the lower the number the more that sare is concentrated in that block
bgSAR[,("sare_diff_tr"):=tr_sare-bg_sare]#only in tracts where ==0, would that not count as potentially off
summary(bgSAR[,sare_diff_tr])
table(bgSAR[sare_diff_tr<9,sare_diff_tr])
#now figure out how many of each should be in group quarters by block?
bgSAR[,("tr_sare_hh_match_id"):=
    paste0(tract,sex,first_age,re_code,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,re_code,eth2)]
trHHr[,("tr_sare_hh_match_id"):=
    paste0(tract,sex,first_age,race,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,race,eth2)]
bgSAR[,("tr_HH"):=trHHr[.SD, list(tr_sare), on = .(tr_sare_hh_match_id)]] 
summary(bgSAR[,tr_HH])
table(bgSAR[is.na(tr_HH),ethnicity])
nrow(bgSAR[sare_diff_tr==0&tr_HH>0])

#if sare_diff_tr==0 & tr_HH>0, then assign "In household"
#bgSAR[sare_diff_tr==0&tr_HH>0,("household"):=list("In household")] #replace with logic, below
#check if all the ones that would have been listed this way are included

```

We're going to make the information we have about the structure of the group quarter distributions at the block group level help us decide the rest of how we distribute the household vs. group quarter designations in the block group main file (bgSAR). 

For now, we'll do a quick set of the bgSAR rows that are not matched in trHHr. We'll make a new table, so we don't have to worry about the block groups, and try to get that lined out correctly, below. We'll do two steps. One that lets us get the right number by ethnicity and the other the right number by race (since we only have complete ethnicity for people counted as White).

```{r anti-join to get right structure for group quarters match (forgetting block level)}
#join bgSAR and trHHe by ethnicity, sex, age at tract level, forgetting rest - create bgSAR_eth as the anti-join without race or group quarters.
#By using the ordering from bg_sare and tr_HH (which is tr_sare + tr_sae from HH) we hope to show how preserving the order by block would work.
bgSAR[order(bg_sare),("bg_sare_hh_match_id"):=
    paste0(tract,sex,first_age,re_code,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,re_code,eth2,bg_sare)]
trHHr[order(tr_sare),("bg_sare_hh_match_id"):=
    paste0(tract,sex,first_age,race,eth2,as.character(100000+seq.int(1:.N))),
      by=.(tract,sex,first_age,race,eth2,tr_sare)]
trHHr[,("household"):=list("In household")]
bgSAR[,("household"):=trHHr[.SD, list(household), on = .(bg_sare_hh_match_id)]] 


#join bgSAR and trHHr by race, sex, age at tract level and create bgSAR_gq with the non-matched and without ethnicity




#should be able to count number of H by tr_sare on trHHr order both sides by tr_sare
```

One of our difficulties, above, was that we weren't sure how to distribute some of the race and ethnicity combinations that we knew to be valid at the tract level once we moved to the block level - although we knew distributions at the block level for both race and ethnicity, which gives us a ceiling for the possible misattributions. We have some information on group quarters that may help, if we're careful not to overwrite, but in general the very detailed information about age and race means that the household structure should be added first, with the specifics for quarters added within that structure (since no other designations besides sex, age, race, and ethnicity are given at this point, and so no information is lost). 

We're hoping that some of the structure from additional tables will help us determine how the non-White ethnicity (re_code=="H" or not) should be distributed; accordingly, we have on each row a marker for how many should be in that category by tract, sex, and the detailed age_range. The households need to account for the distribution of people in group quarters by sex, age, race, and ethnicity in order to know how many in each group are left to be distributed.

Group quarters are treated differently in some of the tables and often not included in others. They're characteristics are reported very differently, especially under the ACS rules for small populations, but they are an interesting, too little understood, and often vulnerable population. Let's download the tables from the publicly accessible parts of the 2010 census and see what we can do.

https://www.socialexplorer.com/data/C2010RC/metadata/?ds=SF1&table=P0430; they changed how they were categorized between 2000 and 2010
group quarters are needed b/c hh don't include them - PC03 offers more detail, on population in correctional facilities by age and sex, but it comes out as all NAs.

```{r group quarters to add block}
group_quarters_block_data_from_census <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "P43",county_num = county,
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
bg_group_quarters_data <- as.data.table(group_quarters_block_data_from_census)
bg_group_quarters_data[,4:ncol(bg_group_quarters_data)] <- 
  bg_group_quarters_data[,lapply(.SD[,4:ncol(bg_group_quarters_data)], as.numeric)]
rm(group_quarters_block_data_from_census)
```

And the basic check on integrity of file.
```{r group quarters test downloaded file}
check_summary <- census_table_check(bg_group_quarters_data, 
      "GROUP QUARTERS POPULATION BY SEX BY AGE BY GROUP QUARTERS TYPE","individuals","Total",2) 
cat(check_summary[1])

```

The fact that 18% sum incorrectly is very odd. Let's see if there's an obvious place where it's not working. 
Let's look at a different way of calculating the totals against each other. Here, we test the rows for the subtotals by sex and age against the total of the whole, and everything lines up.

```{r double check on group quarters subtotals}
test <- colSums(bg_group_quarters_data[label=="Total",
                                          4:ncol(bg_group_quarters_data)])*3 ==
    colSums(bg_group_quarters_data[!str_detect(label,"population"),
                                      4:ncol(bg_group_quarters_data)])
length(test[test==FALSE])==0
```
The first test looked at the subgroup sums, and this one will sum at the lowest granularity provided in the tables, ensuring that all people counted as part of the aggregate are also given one and only one label at that level.

```{r triple check on group quarters totals}
test <- colSums(bg_group_quarters_data[label=="Total",
                                          4:ncol(bg_group_quarters_data)])*2 ==
    colSums(bg_group_quarters_data[str_detect(label,"population"),
                                      4:ncol(bg_group_quarters_data)])
length(test[test==FALSE])==0
```

It seems to have been an oddity in how the rows were tallied so that the subtotals across all second level groups were three times the total, but for the lowest level, only twice. Let's go ahead and expand, before making decisions about the tract level data.

```{r expand group quarters block}
bg_group_quarters <- bg_group_quarters_data %>%
  pivot_longer(4:ncol(bg_group_quarters_data),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(tract = str_remove_all(geoid,"_"),
         tract = substr(tract,1,11),
         label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("sex","age_range","institutionalized","gq_type"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(beg_age_gq = case_when(age_range=="Under 18 years" ~ as.numeric(0),
                                age_range=="18 to 64 years" ~ as.numeric(18),
                                age_range=="65 years and over" ~ as.numeric(65)),
         gq_type = case_when(str_detect(gq_type,"College") ~ #catching some idiosyncratic capitalization
                               "College/University student housing",
                             str_detect(gq_type,"Nursing") ~
                               "Nursing facilities",
                             gq_type=="Correctional facilities for adults (101-106)" ~
                               "Correctional facilities for adults",
                             gq_type=="Juvenile facilities (201-203)" ~
                               "Juvenile facilities",
                             gq_type=="Other institutional facilities (401-405)" ~
                               "Other institutional facilities",
                             gq_type=="Other noninstitutional facilities (701-702, 704, 706, 801-802, 900-901, 903-904)" ~
                               "Other noninstitutional facilities")) %>%
  filter(!is.na(gq_type)) %>% #to get rid of aggregations by institutional type
  uncount(number_sams,.id = "bggq_id",.remove = TRUE) 
bggq <- as.data.table(bg_group_quarters) #dyplyr had stripped it of dt
paste0("Number of individuals in file: ", nrow(bggq))
#check that the number of households plus number of group quarters = total population
nrow(bggq)+nrow(trHHr)==nrow(bgSAR)
rm(list = ls(pattern="bg_group_quarters")) #think through all the clean up in the right places!!
```

The age ranges are quite broad, and the absence of race and ethnicity data would make it hard to make assignments with any confidence. However, PCT20 has tract level group quarters by type with race and ethnicity, while PCT21 has tract level group quarters by sex by age by type and PCT22 has the more age ranges (but only over 18) for group quarters by sex and type. We want to join 20, 21, and 22 to get the best match at the tract level, then we'll add the information we have at block.

```{r group quarters to add tract race ethnicity}
group_quarters_tract_type_data_from_census <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "PCT20",county_num = county,
                         block="tract",api_type="dec/sf1",path_suff="est.csv")
tr_re_group_quarters_type_data <- as.data.table(group_quarters_tract_type_data_from_census) %>%
      select(name,label,concept,starts_with(st_county))
tr_re_group_quarters_type_data[,4:ncol(tr_re_group_quarters_type_data)] <- 
  tr_re_group_quarters_type_data[,lapply(.SD[,4:ncol(tr_re_group_quarters_type_data)], as.numeric)]
rm(group_quarters_tract_type_data_from_census)
```


And the basic check on integrity of file.
```{r group quarters test downloaded file}
check_summary <- census_table_check(tr_re_group_quarters_type_data, 
      "GROUP QUARTERS POPULATION BY GROUP QUARTERS TYPE","individuals","Total",3) 
cat(check_summary[1])

```
We should check, just like we did on the block group for group quarters, why the totals don't sum. Here, we do a very ad hoc process on just the overall totals, and not on each race and ethnicity.

```{r double check on tr_re_group quarters subtotals}
test <- colSums(tr_re_group_quarters_type_data[label=="Total"&length(name)==9,
                                          4:ncol(tr_re_group_quarters_type_data)])*2 ==
    colSums(tr_re_group_quarters_type_data[!str_detect(label,"population")&length(name)==9,
                                      4:ncol(tr_re_group_quarters_type_data)])
length(test[test==FALSE])==0
test <- colSums(tr_re_group_quarters_type_data[label=="Total"&length(name)==9,
                                          4:ncol(tr_re_group_quarters_type_data)])*2 ==
    colSums(tr_re_group_quarters_type_data[str_detect(label,"population")&length(name)==9,
                                      4:ncol(tr_re_group_quarters_type_data)])
length(test[test==FALSE])==0
```

For right now, let's expand this group into both a race and ethnicity table.

```{r expand tract group quarters population by type race and ethnicity}
tr_re_group_quarters <- tr_re_group_quarters_type_data %>%
  pivot_longer(4:ncol(tr_re_group_quarters_type_data),names_to = "tract", values_to = "number_sams") %>% 
  mutate(
    re_code = substr(name,7,7),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("institutionalized","gq_type","gq_specs"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(
    gq_type = case_when(str_detect(gq_type,"College") ~
                               "College/University student housing",
                             str_detect(gq_type,"Nursing") ~
                               "Nursing facilities",
                             gq_type=="Correctional facilities for adults (101-106)" ~
                               "Correctional facilities for adults",
                             gq_type=="Juvenile facilities (201-203)" ~
                               "Juvenile facilities",
                             gq_type=="Other institutional facilities (401-405)" ~
                               "Other institutional facilities",
                             gq_type=="Other noninstitutional facilities (701-702, 704, 706, 801-802, 900-901, 903-904)" ~
                               "Other noninstitutional facilities"),
    gq_specs = case_when(str_detect(gq_type,"College") ~ "College/University student housing",
                         str_detect(gq_type,"Nursing") ~ "Nursing facilities/Skilled-nursing facilities",
                        TRUE ~ gq_specs)
  ) %>%
  filter(!is.na(gq_specs)) %>% #to get rid of aggregations by institutional type
  uncount(number_sams,.id = "trregq_id",.remove = TRUE) 
tr_re_group_quarters <- as.data.table(tr_re_group_quarters) 
#Break them into race and ethnicity tables. We'll add them back together once we have a bit more information to help with block group designations
tr_r_gq <- tr_re_group_quarters[re_code%in%race_codes]
tr_e_gq <- tr_re_group_quarters[re_code%in%c("H","I")]
paste0("Number of individuals in group quarters table: ", nrow(tr_r_gq))
#check that the number of households plus number of group quarters = total population
nrow(tr_r_gq)+nrow(trHHr)==nrow(bgSAR)
#clean up
rm(tr_re_group_quarters)
rm(tr_re_group_quarters_type_data)
```

PCT21 is tract level group quarters, with sex by age. It would be nice for our construction to have the relations by sex, age, and race, ethnicity in the same table, but the Census Bureau decided to mask that information. The protection of privacy for the individuals should be balanced with the need to understand potential patterns across categories, but there are a number of places that such analysis could happen. There are, additionally, many ways in which the population characteristics are available, including many data tables not controlled by the Census Bureau that have very detailed information. The problem of privacy is quickly transforming, and there is no clear long-term solution that addresses all goals. In this case, we don't have a direct path to having a better block group distribution by race and ethnicity through the group quarters. The only directly given information is sex and age_3 ("Under 18," "18 to 64," and "65 and over") at the block group and race and ethnicity at the tract level. Let's see if we can still get some hints by triangulation, though

```{r group quarters to add tract sex age}
group_quarters_tract_sex_age_data_from_census <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "PCT21",county_num = county,
                         block="tract",api_type="dec/sf1",path_suff="est.csv")
tr_sex_age_group_quarters_data <- as.data.table(group_quarters_tract_sex_age_data_from_census)%>%
      select(name,label,concept,starts_with(st_county))
tr_sex_age_group_quarters_data[,4:ncol(tr_sex_age_group_quarters_data)] <- 
  tr_sex_age_group_quarters_data[,lapply(.SD[,4:ncol(tr_sex_age_group_quarters_data)], as.numeric)]
rm(group_quarters_tract_sex_age_data_from_census)
```

And the basic check on integrity of file.
```{r group quarters test downloaded file}
check_summary <- census_table_check(tr_sex_age_group_quarters_data, 
      "GROUP QUARTERS POPULATION BY SEX BY AGE BY GROUP QUARTERS TYPE","individuals","Total",5) 
cat(check_summary[1])

```

Here, we check again on the lower level sums, in case something doesn't match at a deeper level.

```{r double check on tr_sa_group quarters subtotals}
test <- colSums(tr_sex_age_group_quarters_data[label=="Total",
                                          4:ncol(tr_sex_age_group_quarters_data)])*3 ==
    colSums(tr_sex_age_group_quarters_data[!str_detect(label,"population"),
                                      4:ncol(tr_sex_age_group_quarters_data)])
length(test[test==FALSE])==0
```

For right now, let's expand this group.

```{r expand tract group quarters population by type sex and age}
tr_sex_age_group_quarters <- tr_sex_age_group_quarters_data %>%
  pivot_longer(4:ncol(tr_sex_age_group_quarters_data),names_to = "tract", values_to = "number_sams") %>% 
  mutate(label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("sex","age_range","institutionalized","gq_type","gq_specs"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(
    beg_age_gq = case_when(age_range=="Under 18 years" ~ as.numeric(0),
                                age_range=="18 to 64 years" ~ as.numeric(18),
                                age_range=="65 years and over" ~ as.numeric(65)),
    gq_type = case_when(str_detect(gq_type,"College") ~
                               "College/University student housing",
                             str_detect(gq_type,"Nursing") ~
                               "Nursing facilities",
                             gq_type=="Correctional facilities for adults (101-106)" ~
                               "Correctional facilities for adults",
                             gq_type=="Juvenile facilities (201-203)" ~
                               "Juvenile facilities",
                             gq_type=="Other institutional facilities (401-405)" ~
                               "Other institutional facilities",
                             gq_type=="Other noninstitutional facilities (701-702, 704, 706, 801-802, 900-901, 903-904)" ~
                               "Other noninstitutional facilities"),
    gq_specs = case_when(str_detect(gq_type,"College") ~ "College/University student housing",
                         str_detect(gq_type,"Nursing") ~ "Nursing facilities/Skilled-nursing facilities",
                        TRUE ~ gq_specs)
  ) %>%
  filter(!is.na(gq_specs)) %>% #to get rid of aggregations by institutional type
  uncount(number_sams,.id = "trsagq_id",.remove = TRUE) 
tr_sa_gq <- as.data.table(tr_sex_age_group_quarters) 
paste0("Number of individuals in group quarters table: ", nrow(tr_sex_age_group_quarters))
#check that the number of households plus number of group quarters = total population
nrow(tr_sa_gq)+nrow(trHHr)==nrow(bgSAR)
#clean up
rm(tr_sex_age_group_quarters_data)
```

And PCT22 is tract level group quarters, 18 years old and over, but with sex by race/ethnicity

```{r group quarters add tract sex type race and ethnicity over 17}
group_quarters_tract_sex_type_data_from_census <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "PCT22",county_num = county,
                         block="tract",api_type="dec/sf1",path_suff="est.csv")
tr_re_sex_type_group_quarters_data <- as.data.table(group_quarters_tract_sex_type_data_from_census) %>%
      select(name,label,concept,starts_with(st_county))
tr_re_sex_type_group_quarters_data[,4:ncol(tr_re_sex_type_group_quarters_data)] <- 
  tr_re_sex_type_group_quarters_data[,lapply(.SD[,4:ncol(tr_re_sex_type_group_quarters_data)], as.numeric)]
rm(group_quarters_tract_sex_type_data_from_census)
```

```{r group quarters test PCT22 file}
check_summary <- census_table_check(tr_re_sex_type_group_quarters_data, 
      "GROUP QUARTERS POPULATION BY SEX  BY GROUP QUARTERS TYPE FOR THE POPULATION 18 YEARS AND OVER","individuals","Total",3) 
cat(check_summary[1])

```

Expand the tract level race, ethnicity, sex, and age data for over 17 group quarters.

```{r expand tract group quarters population by type sex, age, race and ethnicity, warning=FALSE}
tr_re_over17_type_group_quarters <- tr_re_sex_type_group_quarters_data %>%
  pivot_longer(4:ncol(tr_re_sex_type_group_quarters_data),names_to = "tract", values_to = "number_sams") %>% 
  mutate(
    re_code = substr(name,7,7),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("sex","institutionalized","gq_type"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(gq_type = case_when(str_detect(gq_type,"College") ~
                               "College/University student housing",
                             str_detect(gq_type,"Nursing") ~
                               "Nursing facilities",
                             gq_type=="Correctional facilities for adults (101-106)" ~
                               "Correctional facilities for adults",
                             gq_type=="Juvenile facilities (201-203)" ~
                               "Juvenile facilities",
                             gq_type=="Other institutional facilities (401-405)" ~
                               "Other institutional facilities",
                             gq_type=="Other noninstitutional facilities (701-702, 704, 706, 801-802, 900-901, 903-904)" ~
                               "Other noninstitutional facilities")) %>%
  filter(!is.na(gq_type)) %>% #to get rid of aggregations by institutional type
  uncount(number_sams,.id = "trov18gq_id",.remove = TRUE) 
tr_re_over17_gq <- as.data.table(tr_re_over17_type_group_quarters) 
#Break them into race and ethnicity tables.
tr_r_gq_over17 <- tr_re_over17_gq[re_code%in%race_codes]
tr_e_gq_over17 <- tr_re_over17_gq[re_code%in%c("H","I")]
paste0("Number of individuals in group quarters table: ", nrow(tr_r_gq_over17))
#check that the number of households plus number of group quarters = total population
nrow(tr_r_gq_over17)+nrow(tr_sa_gq[age_range=="Under 18 years"])+nrow(trHHr)==nrow(bgSAR)
```

Joining PCT21 (tr_sa_gq) with P43 (bggq), since PCT21 just adds group quarter specifics. This follows the rules for triangle commutativity, but has a potential of mismatching at the block group level so we move it over with a caveat by putting a tr_ prefix on the gq_specs variable (tr_gq_specs).

```{r add gq_spec_count_sa to bggq from tr_sa_gq}
bggq[,("bg_sa_gq_match_id"):=
                    paste0(tract,sex,age_range,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range,gq_type)]
tr_sa_gq[,("bg_sa_gq_match_id"):=
                    paste0(tract,sex,age_range,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range,gq_type)]
bggq[,("tr_gq_specs"):=
                    tr_sa_gq[.SD, list(gq_specs), on = .(bg_sa_gq_match_id)]]
#tests
nrow(bggq[is.na(tr_gq_specs)])==0
test <- table(
  bggq[,tract],
  bggq[,sex],
  bggq[,age_range],
  bggq[,institutionalized],
  bggq[,gq_type],
  bggq[,tr_gq_specs]
)==table(
  tr_sa_gq[,tract],
  tr_sa_gq[,sex],
  tr_sa_gq[,age_range],
  tr_sa_gq[,institutionalized],
  tr_sa_gq[,gq_type],
  tr_sa_gq[,gq_specs]
)
length(test[test==FALSE])==0
```

But now we need to do some better matching, and see if that could also help us determine which group quarter specifics belong in each block group. We know how many we're supposed to have by race and how many by ethnicity of "H" and "I" in households and group quarters, but not in the same place, and we know some age_range information on group quarters, but not at as granular of a level as for the households.  
We know more about the White population, because "White, not Hispanic or Latino" is given, so we match that group first, before moving to the rest.

```{r attempt matching with span for group quarters on race and ethnicity}
tr_r_gq[,("tr_r_count"):=.N,by=c("tract","re_code","gq_type","gq_specs")]

tr_r_gq[re_code=="A",("tr_r_gq_match_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_e_gq[re_code=="I",("tr_r_gq_match_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_r_gq[re_code=="A",("ethnicity"):=
                    tr_e_gq[.SD, list(re_code), on = .(tr_r_gq_match_id)]]
tr_e_gq[re_code=="I",c("matched"):=
                    tr_r_gq[.SD, list(re_code), on = .(tr_r_gq_match_id)]]
#now do ones who are re_code=="A" for race and "H" for ethnicity.
tr_r_gq[re_code=="A"&is.na(ethnicity),("tr_r_gq_match1_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_e_gq[re_code=="H",("tr_r_gq_match1_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_r_gq[re_code=="A"&is.na(ethnicity),("ethnicity"):=
                    tr_e_gq[.SD, list(re_code), on = .(tr_r_gq_match1_id)]]
tr_e_gq[re_code=="H",c("matched"):=
                    tr_r_gq[.SD, list(re_code), on = .(tr_r_gq_match1_id)]]
nrow(tr_r_gq[re_code=="A"])==nrow(tr_e_gq[!is.na(matched)])
#those count as ethnicity known
#now do re_code!="A"; the remaining hispanic are tr_eh_remain_count as an integer for everyone in that subgroup
tr_r_gq[is.na(ethnicity),("tr_r_gq_match2_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_e_gq[is.na(matched),("tr_r_gq_match2_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
tr_e_gq[is.na(matched),("tr_eh_remain_count"):=.N,
           by=.(tract,gq_type,gq_specs)]
tr_r_gq[is.na(ethnicity),("tr_eh_remain_count"):=
                    tr_e_gq[.SD, list(as.integer(tr_eh_remain_count)), 
                               on = .(tr_r_gq_match2_id)]]
#and for matching with over 17, we want to ensure we know how many remain in each tract with ethnicity of H.
tr_e_gq[is.na(matched),("tr_eh_remain_type_count"):=.N,
           by=.(tract,gq_type)]
tr_r_gq[is.na(ethnicity),("tr_eh_remain_type_count"):=
                    tr_e_gq[.SD, list(as.integer(tr_eh_remain_type_count)), 
                               on = .(tr_r_gq_match2_id)]]
#this assigns to every row in a category that is not fully determined, the remaining number of H.
tr_r_gq[is.na(ethnicity)&order(tr_eh_remain_count),
           ("tr_eh_remain_count"):=
             .SD[1,list(as.integer(tr_eh_remain_count))],
           by = .(tract,gq_type,gq_specs)]
tr_r_gq[is.na(ethnicity)&order(tr_eh_remain_type_count),
           ("tr_eh_remain_type_count"):=
             .SD[1,list(as.integer(tr_eh_remain_type_count))],
           by = .(tract,gq_type)]
#look at the following carefully!!! should they be race/eth or eth/race? and what happens div/0???
tr_r_gq[is.na(ethnicity),
           ("tr_r_eh_spec_prob"):=list(tr_r_count/tr_eh_remain_count),
           by = .(tract,gq_type,gq_specs)]
tr_r_gq[is.na(ethnicity),
           ("tr_r_eh_type_prob"):=list(tr_r_count/tr_eh_remain_type_count),
           by = .(tract,gq_type)]
#prob only need the ones by spec!
paste0("The summary for probability by specifics is: ")
summary(tr_r_gq$tr_r_eh_spec_prob)
paste0("The summary for probability by type is: ")
summary(tr_r_gq$tr_r_eh_type_prob)
paste0("There remain ",nrow(tr_e_gq[re_code=="H"])-(nrow(tr_r_gq[re_code=="A"])-nrow(tr_e_gq[re_code=="I"]))," non-White Hispanic or Latino individuals that have not been assigned a matching race")  
nrow(tr_e_gq[is.na(matched)])==nrow(tr_e_gq[re_code=="H"])-
  (nrow(tr_r_gq[re_code=="A"])-nrow(tr_e_gq[re_code=="I"]))
```

Once we have expanded each matching category of guest quarter type and specifics to have the count for that category of possible Hispanic or Latino, we know by adjunction that the ones without any matching categories across guest quarter specifics for that tract must not be Hispanic or Latino. 

```{r add not Hispanic or Latino to the non-matched categories by }
paste0("There were ",nrow(tr_e_gq[is.na(matched)])," who were not matched in the ethnicity tables (i.e., non-White Hispanic or Latino)")
paste0("There were ",nrow(tr_r_gq[!is.na(tr_eh_remain_count)])," who could have matched by gq_specs and ",
       nrow(tr_r_gq[!is.na(tr_eh_remain_type_count)])," who could have matched by gq_type.")
paste0("Assigning Not Hispanic or Latino to ",nrow(tr_r_gq)-nrow(tr_r_gq[re_code=="A"|!is.na(tr_eh_remain_type_count)])," rows.")
tr_r_gq[is.na(tr_eh_remain_type_count)&is.na(ethnicity),
                  ("ethnicity"):=fcase(re_code=="B","J",
                                       re_code=="C","K",
                                       re_code=="D","L",
                                       re_code=="E","M",
                                       re_code=="F","N",
                                       re_code=="G","O",
                                       default = "def")]
nrow(tr_r_gq[ethnicity=="def"])==0
nrow(tr_r_gq[!is.na(ethnicity)])+
  nrow(tr_r_gq[!is.na(tr_eh_remain_type_count)])==
  nrow(tr_r_gq)
```

We can't fully match with the ethnicity tables because "H" is only listed for the Whites who identify as Hispanic or Latino, and the others are spread out by race in a way that we don't yet know. We were able to identify quite a few that could not match, however, and to assign them their ethnicity as not Hispanic or Latino definitively in the last step.
We have an interesting table which has the group quarters by the same variables, but only for people over 17 (over 95% are) and without the final specifics column. Let's try our same trick with joining the ethnicity and race tables.

```{r attempt matching with sex race and ethnicity over 17 for group quarters}
#tr_r_gq_over17[,("tr_r_count"):=.N,by=c("tract","re_code","sex","gq_type")]
tr_r_gq_over17[re_code=="A",("tr_r_gq_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_e_gq_over17[re_code=="I",("tr_r_gq_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_r_gq_over17[re_code=="A",("ethnicity"):=
                    tr_e_gq_over17[.SD, 
                                      list(re_code), 
                                      on = .(tr_r_gq_match_id)]]
tr_e_gq_over17[re_code=="I",c("matched"):=
                    tr_r_gq_over17[.SD, list(re_code), on = .(tr_r_gq_match_id)]]
#now do ones who are re_code=="A" for race and "H" for ethnicity.
tr_r_gq_over17[re_code=="A"&is.na(ethnicity),("tr_r_gq_match1_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_e_gq_over17[re_code=="H",("tr_r_gq_match1_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_r_gq_over17[re_code=="A"&is.na(ethnicity),("ethnicity"):=
                    tr_e_gq_over17[.SD, list(re_code), on = .(tr_r_gq_match1_id)]]
tr_e_gq_over17[re_code=="H",c("matched"):=
                    tr_r_gq_over17[.SD, list(re_code), on = .(tr_r_gq_match1_id)]]
#those count as ethnicity known
table(tr_r_gq_over17$re_code,tr_r_gq_over17$ethnicity)
#now do rest with only what we can know - i.e., count of hispanic remaining by gq_type
tr_r_gq_over17[is.na(ethnicity),("tr_r_gq_match2_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_e_gq_over17[is.na(matched),("tr_r_gq_match2_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_e_gq_over17[is.na(matched),("tr_eh_remain_type_count"):=.N,
           by=.(tract,sex,gq_type)]
tr_r_gq_over17[is.na(ethnicity),("tr_eh_remain_type_count"):=
                    tr_e_gq_over17[.SD, 
                                      list(as.integer(tr_eh_remain_type_count)), 
                                      on = .(tr_r_gq_match2_id)]]
paste0("There are ",
nrow(tr_r_gq_over17[!is.na(tr_eh_remain_type_count)]),
" who were assigned a category and could possibly still be Hispanic or Latino.")

tr_r_gq_over17[order(tr_eh_remain_type_count),#so no leading NAs
                  ("tr_eh_remain_type_count"):=
             .SD[1,list(as.integer(tr_eh_remain_type_count))],
           by = .(tract,re_code,gq_type)]

paste0("There are ",nrow(tr_r_gq_over17)-
(nrow(tr_r_gq_over17[!is.na(tr_eh_remain_type_count)])+
  nrow(tr_r_gq_over17[!is.na(ethnicity)])),
" people who do not match with any of the gq_types that are in the ethnicity tables, and so must not be Hispanic or Latino")
#add ethnicity to rows that can't be H by elimination on type remaining
tr_r_gq_over17[is.na(tr_eh_remain_type_count)&is.na(ethnicity),
                  ("ethnicity"):=fcase(re_code=="B","J",
                                       re_code=="C","K",
                                       re_code=="D","L",
                                       re_code=="E","M",
                                       re_code=="F","N",
                                       re_code=="G","O",
                                       default = "def")]
nrow(tr_r_gq_over17[ethnicity=="def"])==0
nrow(tr_r_gq_over17[!is.na(ethnicity)])+
  nrow(tr_r_gq_over17[!is.na(tr_eh_remain_type_count)])==
  nrow(tr_r_gq_over17)

```

Now let's see what we can do to add the two versions of the race and ethnicity files together, and to see how it might point to a better final construction. What we've done is whittled away at the combinations that are known, with more specific categorizations that are within the constructions we were able to use for reduction automatically distributing within those cells without any information lost. So, for example, the information about sex can be distributed without issues within those cells where there are no non-determined individual rows -- when re_code=="A" (White), for example, but other categories within the tracts are also fully determined and so can also have sex distributed with confidence that it will match the original assignments by the Census Bureau. 


```{r match over 17 and full on all known categories}
tr_r_gq[,
           ("tr_r17_gq_match_id"):=
                    paste0(tract,re_code,ethnicity,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,ethnicity,gq_type)]
tr_r_gq_over17[,
                  ("tr_r17_gq_match_id"):=
                    paste0(tract,re_code,ethnicity,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,ethnicity,gq_type)]
tr_r_gq[,("sex"):=
                    tr_r_gq_over17[.SD,list(sex), 
                     on = .(tr_r17_gq_match_id)]]
tr_r_gq_over17[,("matched17"):=
                    tr_r_gq[.SD,list(tract), 
                     on = .(tr_r17_gq_match_id)]]
#number successfully matched
paste0("There are ",nrow(tr_r_gq_over17)," rows over 17 and with sex given, ",
nrow(tr_r_gq[!is.na(sex)]), " in the total table now have sex assigned by matching with the over 17 table, which leaves ",
nrow(tr_r_gq[is.na(sex)]), " who do not have sex assigned in the all age table of ",
nrow(tr_r_gq))
paste0("From the ethnicity matching, above, we still have ",
nrow(tr_r_gq[is.na(ethnicity)]), " who don't have ethnicity assigned and ",
 nrow(tr_r_gq[is.na(sex)&is.na(ethnicity)]),
      " that do not have ethnicity matched and did not get sex (or over 18) assigned")
#number that had ethnicity and race, but didn't match - those should get a count
nrow(tr_r_gq[!is.na(sex)&!is.na(ethnicity)])
#number in over 17 that had ethnicity but didn't match
paste0("Of the ",nrow(tr_r_gq_over17[!is.na(ethnicity)]) ,
       " in the over 17 table with ethnicity assigned, all but ",
nrow(tr_r_gq_over17[!is.na(matched17)&is.na(ethnicity)]), " matched. However, ",
nrow(tr_r_gq[is.na(sex)]), " still need a final determination for sex in the overall group quarters race table, in order to match with the givens in bggq")
```

The idea with tr_r_eh_spec_prob is that if a row by race is showing up in the gq_spec, but not in the same gq_spec by ethnicity, then we know something about how they are distributed. We expect a lot to be determined by the final cast by tract to bgSAR, with the blocks over-riding from here. 

```{r join over17 gq but those without ethnicity and ordered by the tr_r_eh_spec_prob}
tr_r_gq[is.na(sex)&order(tr_r_eh_spec_prob),
           ("tr_r17_gq_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+seq.int(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq_over17[is.na(matched17)&order(tr_eh_remain_type_count),
                  ("tr_r17_gq_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+seq.int(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq[is.na(sex),("sex"):=
                    tr_r_gq_over17[.SD,list(sex), 
                     on = .(tr_r17_gq_match_id)]]
tr_r_gq_over17[is.na(matched17),("matched17"):=
                    tr_r_gq[.SD,list(tract), 
                     on = .(tr_r17_gq_match_id)]]
#number successfully matched
paste0("There are ",nrow(tr_r_gq_over17)," rows over 17 and with sex given, ",
nrow(tr_r_gq[!is.na(sex)]), " in the total table now have sex assigned by matching with the over 17 table, which leaves ",
nrow(tr_r_gq[is.na(sex)]), " who do not have sex assigned in the all age table of ",
nrow(tr_r_gq))
paste0("From the ethnicity matching, above, we still have ",
nrow(tr_r_gq[is.na(ethnicity)]), " who don't have ethnicity assigned and ",
 nrow(tr_r_gq[is.na(sex)&is.na(ethnicity)]),
      " that do not have ethnicity matched and did not get sex (or over 18) assigned")
#number that had ethnicity and race, but didn't match - those should get a count
paste0("There are ",
nrow(tr_r_gq[!is.na(sex)&!is.na(ethnicity)]),
" in the group quarters race file who have race and ethnicity assigned to them")
#number in over 17 that had ethnicity but didn't match
paste0("Of the ",nrow(tr_r_gq_over17[!is.na(ethnicity)]) ,
       " in the over 17 table with ethnicity assigned, all but ",
nrow(tr_r_gq_over17[!is.na(matched17)&is.na(ethnicity)]), " matched. However, ",
nrow(tr_r_gq[is.na(sex)]), " still need a final determination for sex in the overall group quarters race table, in order to match with the givens in bggq.")
```

All we have done up to this point is add as much information as we can deduce from the over 17 group quarters table to the complete group table, knowing that there is not specificity in the age groups. We have given a best guess for sex and age group to the tables where we know all the race and ethnicity designations. 

Our next step is to see if using the data on sex, age range and group quarters types and specifics, by tract, we can further eliminate some of the categories we might assign, in preparation for then using it with the full population and household tables to finally assign all the designations, as narrowed down by matching with the overall population tables. 

```{r matching under 18 by sex, type, and gq_specs on group quarter tables}
tr_r_gq[,("tr_sts_gq_match_id"):=
                    paste0(tract,sex,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,gq_specs)]
bggq[age_range!="Under 18 years",("tr_sts_gq_match_id"):=
                    paste0(tract,sex,gq_type,tr_gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,tr_gq_specs)]
bggq[age_range!="Under 18 years",c("sts_re_code","sts_ethnicity"):=
                    tr_r_gq[.SD,c(list(re_code),list(ethnicity)), 
                     on = .(tr_sts_gq_match_id)]]
tr_r_gq[,("matched_sts"):=
                    bggq[.SD,list(tract), 
                     on = .(tr_sts_gq_match_id)]]
#how many matches - put in right paste0 comments, etc.
nrow(tr_r_gq[!is.na(matched_sts)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_re_code)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_ethnicity)]) #FALSE b/c a few are NAs
```

There are 1,597 that didn't match by sex at the specifics level. Because the sex assigned to the race tables had come originally from a place where only group quarters type was certain, but we want to not lose any of the group quarter specifics by race and ethnicity, we match those remaining ones without sex. The designation for sex in the bggq table is definitive, after all, and will be respected as the final designation. 

```{r matching without sex for under 18 by gq_type and gq_specs for group quarter tables}
tr_r_gq[is.na(matched_sts),("tr_sts_gq_match2_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
bggq[age_range!="Under 18 years"&is.na(sts_re_code),("tr_sts_gq_match2_id"):=
                    paste0(tract,gq_type,tr_gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,tr_gq_specs)]
bggq[age_range!="Under 18 years"&is.na(sts_re_code),c("sts_re_code","sts_ethnicity"):=
                    tr_r_gq[.SD,c(list(re_code),list(ethnicity)), 
                     on = .(tr_sts_gq_match2_id)]]
tr_r_gq[is.na(matched_sts),("matched_sts"):=
                    bggq[.SD,list(tract), 
                     on = .(tr_sts_gq_match2_id)]]
#how many matches
nrow(tr_r_gq[!is.na(matched_sts)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_re_code)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_ethnicity)]) #FALSE b/c a few are NAs
```

We now have a reasonably strong match on race and ethnicity for the group quarters at the tract level, for those over 17. We simply don't have more information for those under 18, so match race and ethnicity with group quarters type and group quarters specifics, which we can then match back to the overall block group tables.
```{r matching without sex for under 18 by gq_type and gq_specs for group quarter tables}
tr_r_gq[is.na(matched_sts),("tr_sts_gq_match3_id"):=
                    paste0(tract,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,gq_specs)]
bggq[age_range=="Under 18 years"&is.na(sts_re_code),("tr_sts_gq_match3_id"):=
                    paste0(tract,gq_type,tr_gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,gq_type,tr_gq_specs)]
bggq[age_range=="Under 18 years"&is.na(sts_re_code),c("sts_re_code","sts_ethnicity"):=
                    tr_r_gq[.SD,c(list(re_code),list(ethnicity)), 
                     on = .(tr_sts_gq_match3_id)]]
tr_r_gq[is.na(matched_sts),("matched_sts"):=
                    bggq[.SD,list(tract), 
                     on = .(tr_sts_gq_match3_id)]]
#how many matches
nrow(tr_r_gq[!is.na(matched_sts)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_re_code)])
nrow(tr_r_gq[!is.na(matched_sts)])==nrow(bggq[!is.na(sts_ethnicity)]) #FALSE b/c a few are NAs
```

#Discussion of some nudges and what they mean

We should also talk, at some point, about the temptation to fidget with the numbers. When do we bring in outside knowledge to give detail to the picture? If there are a handful of 17 year olds - and perhaps one or two exceptional students at 16 - in on-campus housing, that's not inconceivable, but we don't want them to have ages between 1 and 18 distributed to them on a normal distribution of some sort. Even inside the 18 to 64 years group, we know from experience that on-campus housing is overwhelmingly young adults, with many dorms having significantly more in their first and second years of school, as the older students move off-campus. Equally, the handful of 18 year olds who are in correctional facilities intended for juveniles should not be assigned randomly simply any age between 18 and 64, and the youngest ones should still be at least in their teens. Let's look at a few of those distributions, and then think about whether our process of elimination helps capture those differences - or what else we should bring to bear on the process later. If elimination works, then the idea is that the number of 17 year olds who live in a block group that has the college dorms in it will simply be picked up in the last merge with the block group by the 23 age groups available at that level (single year is at the tract level; in this example, "15 to 17 years" would be the relevant distinction at the block group level). Of course, if that block group also includes a nearby subdivision, we simply cannot know if the 15 to 17 year old is on campus or living with their parents without more information. There are things in the family and household files that may help, but we have to be carefult. Here are some obvious places where the age groups are potentially going to cause problems.

```{r difficult cases on age in group quarters}
paste0("Group homes intended for adults")
table(bggq[tr_gq_specs=="Group homes intended for adults (801)",age_range])
paste0("Residential treatment centers for adults")
table(bggq[tr_gq_specs=="Residential treatment centers for adults (802)",age_range])
paste0("Correctional facilities intended for juveniles")
table(bggq[tr_gq_specs=="Correctional facilities intended for juveniles (203)",age_range])
paste0("College/University student housing")
table(bggq[tr_gq_specs=="College/University student housing",age_range])
paste0("Residential treatment centers for adults")
table(bggq[tr_gq_specs=="Residential treatment centers for adults (802)",age_range])
paste0("Local jails and other municipal confinement facilities")
table(bggq[tr_gq_specs=="Local jails and other municipal confinement facilities (104)",age_range])
```

Group quarters are not concentrated, with most block groups having only one kind of residence, even as specified at the detailed level, which means that further specification by age isn't necessary. As part of being as complete as possible, we add a bit of a step to give preference to some things known outside the data tables themselves, as a matter of interpretation. Although the actual distribution still decides the structure of the final distribution, it is possible for some nudge toward one or the other subtype to be given with this technique. This may go against things that the Census Bureau had introduced as part of their deliberate attempts to conceal some identities, such as instituting differential privacy or simply switching some people into different cells.

```{r how many tracts have multiple gq_specs}
bggq[,("num_gq_specs_tr"):=length(unique(tr_gq_specs)),by=.(tract)]
summary(bggq[,num_gq_specs_tr])
bggq[,("num_gq_specs_bg"):=length(unique(tr_gq_specs)),by=.(geoid)]
summary(bggq[,num_gq_specs_bg])
bggq[,("num_gq_type_bg"):=length(unique(gq_type)),by=.(geoid)]
summary(bggq[,num_gq_type_bg])
#can look at the ones with the most num_gq_specs_tr and then see how well they matched
```

The exercise of matching on the tables is useful because we found several places where we'd been careless - which gives us the opportunity to emphasize how much of the construction is dependent on details that are hard to automate. The necessity of creating a concrete representation, like the exercise of determining that a formula is decidable (or effectively computable), is a good heuristic, but does not provide its own answer. What we know here is that the Census Bureau constructed its tables from a single grounded representation of the population, and the published tables are all transformations of that underlying overall representation. We can do a few things to clean up the matches where the categories given above point to age ranges that would be significantly misleading if interpreted as equally belonging to the whole range. The small number of 17 year olds living on college campuses should not be confused with the 8 year olds living with their faculty parents next door, but there's no algorithmic determination we can use internally to exclude all possible edge cases.

For the particular case of group quarters, the question is whether there are two types of group quarters in a block group that would potentially have confusion between them based on age or other characteristics. 

Consequently, we will just do some broad assignments of distributions of age, and then order the matching algorithm so that the rows are most likely to follow something like that order. The actual distributions will rule the final assignments, and their structure is what we want to maintain throughout so that we can reproduce the same tables, as needed. 

For the guest quarter specifics (gq_specs), we create a count that incorporates some broad understanding of the categories. We were able to find other published tables of group quarter populations, at higher geographic levels but with 15-19 years as the breakoff, and confirm that the under 18 year olds in college dorms, for example, were not under 15. http://proximityone.com/group_quarters.htm. Our explicit presupposition is that differences at the block group level in housing opportunities for group quarters will constrain the distributions to the right population. We created a beginning age for the group quarters when we first made the tables, and will tweak it here for the ordering, with no very sophisticated process for normalizing distributions or intervening at the individual level.

```{r assigning order to gq_specs}
bggq[tr_gq_specs=="Correctional facilities intended for juveniles (203)"&
          age_range=="18 to 64 years",
        ("beg_age_gq"):=17] #does not set value of final age to 17, but orders this row for matching before the rest of the 18 to 64 year olds.
bggq[tr_gq_specs=="Group homes for juveniles (non-correctional) (201)"&
          age_range=="18 to 64 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Residential treatment centers for juveniles (non-correctional) (202)"&
          age_range=="18 to 64 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Local jails and other municipal confinement facilities (104)"&
          age_range=="Under 18 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Local jails and other municipal confinement facilities (104)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
bggq[tr_gq_specs=="Group homes intended for adults (801)"&
          age_range=="Under 18 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Workers' group living quarters and Job Corps centers (901)"&
          age_range=="Under 18 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Workers' group living quarters and Job Corps centers (901)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
bggq[tr_gq_specs=="Residential treatment centers for adults (802)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
bggq[tr_gq_specs=="College/University student housing"&
          age_range=="Under 18 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="Federal detention centers (101)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
bggq[tr_gq_specs=="State prisons (103)"&
          age_range=="Under 18 years",
        ("beg_age_gq"):=17]
bggq[tr_gq_specs=="State prisons (103)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
bggq[tr_gq_specs=="Correctional residential facilities (105)"&
          age_range=="65 years and over",
        ("beg_age_gq"):=64]
```

We will talk a bit more, below, about how to understand what sort of difference these nudges made, but for right now we should concentrate on finishing the matches at the level that we can know.

#Finishing the bgSAR matches for group quarters and households


We remember that, above, we had only fully matched bgSAR on households for Whites, since we only had complete information for that race and ethnicity. Now we have some knowledge of the race and ethnicity of other individuals in group quarters and can make sure that we assign race and ethnicity with as much precision as possible at the block group level.

```{r testing bgSAR and trHHr and bggq}
nrow(bgSAR)==nrow(trHHr)+nrow(bggq)
nrow(bgSAR[re_code=="A"])==nrow(trHHr[race=="A"])+nrow(bggq[sts_re_code=="A"])
nrow(bgSAR[re_code=="B"])==nrow(trHHr[race=="B"])+nrow(bggq[sts_re_code=="B"])
nrow(bgSAR[re_code=="C"])==nrow(trHHr[race=="C"])+nrow(bggq[sts_re_code=="C"])
nrow(bgSAR[re_code=="D"])==nrow(trHHr[race=="D"])+nrow(bggq[sts_re_code=="D"])
nrow(bgSAR[ethnicity=="I"])==nrow(trHHr[ethnicity=="I"])+nrow(bggq[sts_ethnicity=="I"])
```

#Moving Group Quarter Information over to block group individuals table

Our idea now is to move the information we have about group quarters over to matching individuals in our foundational population file at the block_group level (bgSAR). 

Since we don't have age groups in very good detail for the group quarters, and we have done a bit of nudging, what we'll do is match the young and then the old, then the middle. We had assigned sts_re_code as a guess to the block groups. We see that the numbers aren't quite right. What we'll do is carry as many over as we can where the sex also matches, and then allow the last ones to lose the assigned sts_re_code and sts_ethnicity, since they weren't definitive. The bgSAR only has the household vs. group quarter designation for the White population, and we'll use that matching to help refine the cases, below.

What we had with the bgSAR, above, was a measure of which blocks had the largest diversion from the tract for that combination of sex, age, race and ethnicity (bg_sare) and  tr_HH, which was drawn from the same combinations at the tract level in the household file. 

STOPPED HERE!!
Plan: use the bgSAR tr_sare to order and create a new file with the bgSAR that doesn't match a trHHr, then match that with bggq, then to bgSAR as group quarters at the block level, then rematch with the trHHr, with the assumption that it now has the blocks right.   



```{r matching group quarter tables to bgSAR for 17 y.o White population}
bggq[,("household"):="In group quarters"]
#start with the edge cases
bgSAR[first_age=="15",("sar_gq_15_match_id"):=
                    paste0(geoid,household,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,re_code,ethnicity)]
bggq[beg_age_gq=="17",("sar_gq_15_match_id"):=
                    paste0(geoid,household,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age=="15",
         c("institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_15_match_id)]]
bggq[beg_age_gq=="17"&sts_re_code=="A",("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_15_match_id)]]
nrow(bgSAR[!is.na(institutionalized)])==nrow(bggq[!is.na(SAR_match)])
#this gives us the 15-17 year olds that are in unusual places
table(bgSAR$group_quarter_type)

```
This is not exact, and we will have to fill in some of the missing pieces as we go along, but it gives us a start.
Let's try the oldest group for those matches, and then work toward the middle.

```{r matching group quarter tables to bgSAR for senior White population}
bgSAR[first_age=="62"&re_code=="A",("sar_gq_62_match_id"):=
                    paste0(geoid,household,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,re_code,ethnicity)]
bggq[beg_age_gq=="64"&sts_re_code=="A"&is.na(SAR_match),("sar_gq_62_match_id"):=
                    paste0(geoid,household,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age=="62"&re_code=="A",
         c("institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_62_match_id)]]
bggq[beg_age_gq=="64"&sts_re_code=="A"&is.na(SAR_match),("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_62_match_id)]]
nrow(bgSAR[!is.na(institutionalized)])==nrow(bggq[!is.na(SAR_match)])
#this gives us 13 white 62-65 year olds that are in unusual places
table(bgSAR[first_age=="62",group_quarter_type])

```

Now do the rest of the group quarters who are White

```{r matching White group quarters by below 18 and then over 65 then rest}
bgSAR[first_age<18&re_code=="A"&is.na(institutionalized),("sar_gq_18_match_id"):=
                    paste0(geoid,household,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,re_code,ethnicity)]
bggq[beg_age_gq<18&sts_re_code=="A"&is.na(SAR_match),("sar_gq_18_match_id"):=
                    paste0(geoid,household,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age<18&re_code=="A"&is.na(institutionalized),
         c("institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_18_match_id)]]
bggq[beg_age_gq<18&sts_re_code=="A"&is.na(SAR_match),("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_18_match_id)]]
nrow(bgSAR[!is.na(institutionalized)])==nrow(bggq[!is.na(SAR_match)])
#now for over 65
bgSAR[first_age>=65&re_code=="A"&is.na(institutionalized),("sar_gq_64_match_id"):=
                    paste0(geoid,household,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,re_code,ethnicity)]
bggq[beg_age_gq>=64&sts_re_code=="A"&is.na(SAR_match),("sar_gq_64_match_id"):=
                    paste0(geoid,household,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age>=65&re_code=="A"&is.na(institutionalized),
         c("institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_64_match_id)]]
bggq[beg_age_gq>=64&sts_re_code=="A"&is.na(SAR_match),("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_64_match_id)]]
nrow(bgSAR[!is.na(institutionalized)])==nrow(bggq[!is.na(SAR_match)])
#now for middle group, allowing some not to match because of the guesses on sts_re_code, etc.
bgSAR[first_age>15&re_code=="A"&is.na(institutionalized),("sar_gq_mid_match_id"):=
                    paste0(geoid,household,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,re_code,ethnicity)]
bggq[beg_age_gq>=17&sts_re_code=="A"&is.na(SAR_match),("sar_gq_mid_match_id"):=
                    paste0(geoid,household,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,household,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age>15&re_code=="A"&is.na(institutionalized),
         c("institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_mid_match_id)]]
bggq[beg_age_gq>=17&sts_re_code=="A"&is.na(SAR_match),("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_mid_match_id)]]
nrow(bgSAR[!is.na(institutionalized)])==nrow(bggq[!is.na(SAR_match)])
#test how many White in group quarters as designated by bgSAR already didn't match
```
FOR REST, THEY WON'T MATCH BY HOUSEHOLD IN BGSAR - JUST MATCH BY AGES AGAIN, NOT WHITE, THEN A FINAL MATCH WITHOUTH RE_CODE OR ETHNICITY, BUT KEEPING SEX? 



```{r matching group quarter tables to SAR by bg then tract for 17 y.o. not White}

bgSAR[first_age=="15"&re_code!="A",("sar_gq_nw15_match_id"):=
                    paste0(geoid,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,re_code,ethnicity)]
bggq[beg_age_gq=="17"&sts_re_code!="A",("sar_gq_nw15_match_id"):=
                    paste0(geoid,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age=="15"&re_code!="A",
         c("household","institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(household),list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_nw15_match_id)]]
bggq[beg_age_gq=="17"&sts_re_code!="A",("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_nw15_match_id)]]
nrow(bgSAR[first_age=="15"&re_code!="A"&!is.na(institutionalized)])== #150
  nrow(bggq[beg_age_gq=="17"&sts_re_code!="A"])                      #179
#false because some sts_ethnicity are missing - so do it again without ethnicity
bgSAR[first_age=="15"&re_code!="A"&is.na(institutionalized),
         ("sar_gq_match1_id"):=
                    paste0(geoid,sex,re_code,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,re_code)]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("sar_gq_match1_id"):=
                    paste0(geoid,sex,sts_re_code,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,sts_re_code)]
bgSAR[first_age=="15"&re_code!="A"&is.na(institutionalized),
         c("household","institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(household),list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_match1_id)]]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_match1_id)]]
nrow(bgSAR[first_age=="15"&re_code!="A"&!is.na(institutionalized)])==
  nrow(bggq[beg_age_gq=="17"&sts_re_code!="A"])
#still false, so match by tract
bgSAR[first_age=="15"&re_code!="A"&is.na(institutionalized),
         ("sar_gq_match2_id"):=
                    paste0(tract,sex,re_code,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,re_code)]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("sar_gq_match2_id"):=
                    paste0(tract,sex,sts_re_code,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,sts_re_code)]
bgSAR[first_age=="15"&re_code!="A"&is.na(institutionalized),
         c("household","institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(household),list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_match2_id)]]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_match2_id)]]
nrow(bgSAR[first_age=="15"&re_code!="A"&!is.na(institutionalized)])==
  nrow(bggq[beg_age_gq=="17"&sts_re_code!="A"])
#tried matching by tract and only got one more
#let's change first_age to 18, but keeping the SAR_match so overall numbers match - will be 13 off on age...
bgSAR[first_age=="18"&re_code!="A"&is.na(institutionalized),
         ("sar_gq_match3_id"):=
                    paste0(geoid,sex,re_code,ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,re_code,ethnicity)]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("sar_gq_match3_id"):=
                    paste0(geoid,sex,sts_re_code,sts_ethnicity,as.character(100000+sample(1:.N))),
                  by=.(geoid,sex,sts_re_code,sts_ethnicity)]
bgSAR[first_age=="18"&re_code!="A"&is.na(institutionalized),
         c("household","institutionalized","group_quarter_type","group_quarter_specifics"):=
                    bggq[.SD,c(list(household),list(institutionalized),list(gq_type),list(tr_gq_specs)), 
                     on = .(sar_gq_match3_id)]]
bggq[beg_age_gq=="17"&sts_re_code!="A"&is.na(SAR_match),
        ("SAR_match"):=
                    bgSAR[.SD,list(geoid), 
                     on = .(sar_gq_match3_id)]]
nrow(bgSAR[!is.na(institutionalized)])==
  nrow(bggq[beg_age_gq=="17"&sts_re_code!="A"])

```

Now we do the same matching for re_code=="A" ("White Alone"). We were already able to make the determination of which individuals were in group quarters, so can match on that as well. [[copy above, but with ==A and household in paste]]



Let's compare the two ways of doing the matching and see what difference it makes for a couple of very specific places.

We know the area around our own campus well, and there are some group quarters for students mixed in with residential neighborhoods with a broad range of children. First, let's see if in that block group, the elimination through assignment of people listed as "In households" provides enough distinction. We find that everyone in that census block who is in group quarters is in student housing, and that no one under 15 is listed as such; however, we also find a number of older people. The totals for the populations match, and can be represented as commuting in terms of the relations between age, sex, race, and ethnicity. 

```{r looking at group quarters after households removed for age range}
nrow(bggq[geoid=="48_201_312000_2"&sts_re_code=="A"])
nrow(bggq[tract=="48201312000"&sts_re_code=="A"])
nrow(tr_r_gq[tract=="48201312000"&re_code=="A"])
nrow(bgSAR[geoid=="48_201_312000_2"&household=="In group quarters"])
nrow(bggq[tract=="48201312000"&sts_re_code=="A"])
nrow(bgSAR[tract=="48201312000"&household=="In group quarters"])
table(bggq[geoid=="48_201_312000_2",tr_gq_specs])
table(bgSAR[geoid=="48_201_312000_2"&household=="In group quarters",age_range])
table(bggq[tract=="48201312000",tr_gq_specs])
table(bgSAR[tract=="48201312000"&household=="In group quarters",age_range])
table(bggq[tract=="48201312000",institutionalized])
table(bgSAR[tract=="48201312000"&household=="In group quarters",age_range])
```

For this group, it doesn't seem like any further specification by age range helps - it's all done by virtue of the specific characteristics of the block group. Let's also look at one with something that feels like an odd distribution around the ages - that is, where we have a group home intended for adults, at the block group level, the totals don't work, so we'll look at it at the tract level, with a reminder for ourselves that we'll need to account for the block groups better later.

```{r looking at group quarters after households removed for age range}
table(bggq[geoid=="48_201_531700_1"&sts_re_code=="A",tr_gq_specs])
table(bggq[geoid=="48_201_531700_1"&sts_re_code=="A",age_range])
table(bgSAR[geoid=="48_201_531700_1"&household=="In group quarters"&re_code=="A",age_range])
#and by tract
table(bggq[tract=="48201531700"&sts_re_code=="A",tr_gq_specs])
table(bggq[tract=="48201531700"&sts_re_code=="A",age_range])
table(tr_sa_gq[tract=="48201531700",gq_specs])
table(tr_sa_gq[tract=="48201531700",age_range])
table(bgSAR[tract=="48201531700"&household=="In group quarters"&re_code=="A",age_range])
#and by type 
table(bggq[tract=="48201531700"&sts_re_code=="A",gq_type])
table(bggq[tract=="48201531700"&sts_re_code=="A",age_range])
table(tr_sa_gq[tract=="48201531700",gq_type])
table(tr_sa_gq[tract=="48201531700",age_range])
table(bgSAR[tract=="48201531700"&household=="In group quarters"&re_code=="A",age_range])
#and a different tract
table(bggq[tract=="48201312300"&sts_re_code=="A",tr_gq_specs])
table(bggq[tract=="48201312300"&sts_re_code=="A",age_range])
table(tr_sa_gq[tract=="48201312300",gq_specs])
table(tr_sa_gq[tract=="48201312300",age_range])
table(bgSAR[tract=="48201312300"&household=="In group quarters"&re_code=="A",age_range])
#and another
table(bggq[tract=="48201252500"&sts_re_code=="A",tr_gq_specs])
table(bggq[tract=="48201252500"&sts_re_code=="A",age_range])
table(tr_sa_gq[tract=="48201252500",gq_specs])
table(tr_sa_gq[tract=="48201252500",age_range])
table(bgSAR[tract=="48201252500"&household=="In group quarters"&re_code=="A",age_range])
#and another
table(bggq[tract=="48201320200"&sts_re_code=="A",tr_gq_specs])
table(bggq[tract=="48201320200"&sts_re_code=="A",age_range])
table(tr_sa_gq[tract=="48201320200",gq_specs])
table(tr_sa_gq[tract=="48201320200",age_range])
table(bgSAR[tract=="48201320200"&household=="In group quarters"&re_code=="A",age_range])
```

This tells us that there is some mismatch between the block group and the tract level, but that otherwise things match up as we had hoped. What we can do is create a secondary table where we join at the tract level, and then redo the block group merge. We could also just do this on the tract level, and then do the block group merge only at the very end. 





```{r maybe for joins}


#then do some summaries on the ones that don't have matches

#can I do a count down in each tract?
#not yet - trHHr[,("ethnicity_test"):=fcase(tr_sae<=tr_sare,"H",ethnicity)] #doesn't distribute between races...
#do it for bgSAR after getting bggq numbers by block and doing countdown on them 



##CUT BELOW, but maybe redo test? 
#trHHr[,("household"):=list("In household")] #more convenient for below
#bgSAR[re_code=="A",("bg_saW_hh_match_id"):=
#                    paste0(tract,ethnicity,sex,first_age,as.character(100000+sample(1:.N))),
#                  by=.(tract,ethnicity,sex,first_age)]
#trHHr[race=="A",("bg_saW_hh_match_id"):=
#                    paste0(tract,ethnicity,sex,first_age,as.character(100000+sample(1:.N))),
#                  by=.(tract,ethnicity,sex,first_age)]
#bgSAR[re_code=="A",("household"):=
#                    trHHr[.SD, list(household), on = .(bg_saW_hh_match_id)]]
#if race=="A", and not "In household", then "In group quarters"
#bgSAR[re_code=="A"&is.na(household),("household"):="In group quarters"]
#this adds totals, and can be done later in ways that make it only the remaining H...
#still need to match the other group quarter specific information
#bgSAR[,("bg_eth_total"):=.N,by=.(geoid,ethnicity)]#have to match with ethnicity in that row
#bgSAR[ethnicity=="H",("bg_H_eth_total"):=.N,by=.(geoid,ethnicity)]#if only for H 
#put that value on all rows for the block
#bgSAR[,("bg_H_total"):=.SD[1,list(as.integer(bg_H_eth_total))],
#         by=.(geoid)]
#tests
#nrow(trHHr[race=="A"])==nrow(bgSAR[household=="In household"])
#test <- table(
#  bgSAR[re_code=="A"&household=="In household",tract],
#  bgSAR[re_code=="A"&household=="In household",sex],
#  bgSAR[re_code=="A"&household=="In household",ethnicity],
#  bgSAR[re_code=="A"&household=="In household",first_age]
#)==table(
#  trHHr[race=="A",tract],
#  trHHr[race=="A",sex],
#  trHHr[race=="A",ethnicity],
#  trHHr[race=="A",first_age]
#)
#length(test[test==FALSE])==0
```








SHOULD WE DO RE_CODE=="A" FIRST????
THEN JUST HAVE TO DO ORDER(LOWER TO HIGHER ON COMBO) by at smallest level (re_code)

The first part is to use the broad age range by sex and group quarter specifications. Then we'll do two things to the other rows that could have matched, with the plan to integrate the information from multiple tables based on that representation. 

```{r test some tables for possible join}
tr_r_gq_over17[,("tr_sa_count"):=.N,by=c("tract","re_code","sex","gq_type")]
tr_r_gq[,("tr_rr_gq_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq_over17[,("tr_rr_gq_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq[,c("sex_tr17_r","tr_e_sa_gq","tr_e_sa_gq_count"):=
                    tr_r_gq_over17[.SD, 
                                      c(list(sex),list(tr_e_gq),list(as.integer(tr_sa_count))), 
                                      on = .(tr_rr_gq_match_id)]]
tr_r_gq[!is.na(tr_e_sa_gq),("age_over17"):="first pass match"]
nrow(tr_r_gq[!is.na(age_over17)])
nrow(tr_r_gq[!is.na(sex_tr17_r)])
nrow(tr_r_gq[!is.na(tr_e_sa_gq)])
##tests
test <- table(
  tr_r_gq[!is.na(tr_e_sa_gq),tract],
  tr_r_gq[!is.na(tr_e_sa_gq),re_code],
  tr_r_gq[!is.na(tr_e_sa_gq),gq_type]
)==table(
  tr_r_gq_over17[!is.na(tr_e_gq),tract],
  tr_r_gq_over17[!is.na(tr_e_gq),re_code],
  tr_r_gq_over17[!is.na(tr_e_gq),gq_type]
)
length(test[test==FALSE])==0
#then add something to the blanks so we know what they might have been
#could put something in here as part of the testing, to show amount of difference from join??
test <- table(tr_r_gq$tr_e_sa_gq) 
tr_r_gq[,c("sex_tr17_r","tr_e_sa_gq","tr_e_sa_gq_count","tr_re_count"):=
             .SD[1,c(list(sex_tr17_r),list(tr_e_sa_gq),list(as.integer(tr_e_sa_gq_count)),.N)],
           by = .(tract,re_code,gq_type)]
table(tr_r_gq$tr_e_sa_gq)-test

```

Need a general discussion of why we're still treating this as a descriptive problem with zeroing in on what can be known and not propagating growing p-values as marks of uncertainty - i.e., that the problem we have is how can we move between different ways of talking, given that we know that there is a commutative level where the individuals have a way in which they are all described consistently and coherently. We are not asking about whether the sample we have has the same structure as the whole - at least not yet - but whether the structures for talking about the population can maintain their commutativity (whether, more broadly and as we will exploit later, they are isomorphic, and thus can be said to translate back and forth between the various "ways of representing"). This should both let us build the representation and teach us something about the broader framings within which such things are arbitrated, as we assess potential policy, understand residual bias or other systemic weaknesses in approach to the design, and look for ways to represent what is dynamic and changing in a population, as opposed to merely consistently describing that which is. [rules and patterns?]
The idea is that the counts give you the probability, but let's think about what it means to do them "with memory" - T-D Bradley's density. By that metaphor, what we're doing at this stage is zeroing in on the core. We'll confirm the ones that are determined twice in the same way, and then save enough information on each row to know it's probability, with "memory." The age_range designation let's you see where a first pass match would happen, too. 

```{r reducing by eliminating non-matches on race and ethnicity in race file}
#not sure what to do with sex and age?? do ethnicity first
paste0("The distribution of the full ethnicity file is in tr_e_gq: ")
table(tr_r_gq$tr_e_gq,tr_r_gq$re_code)
paste0("The distribution of the over 17 ethnicity file is in tr_e_sa_gq and includes sex: ")
table(tr_r_gq$tr_e_sa_gq,tr_r_gq$re_code,tr_r_gq$sex_tr17_r)
paste0("Where they don't match: ")
table(tr_r_gq$tr_e_gq,tr_r_gq$tr_e_sa_gq)
paste0("Where they don't match on first pass: ")
table(tr_r_gq[!is.na(age_over17),tr_e_gq],tr_r_gq[!is.na(age_over17),tr_e_sa_gq])
```

Then do add to hh - and resolve with the bgSAR??

MOVE THE COUNTS FROM HR AND GQ to bgSAR, then do some reductions... so everyone that has a match (and there will be a lot more) has a "may_match_gq_sa" with the number from the gq side?

CAN DO THE SAME FOR HOUSEHOLDS AND GROUP QUARTERS, WITH THEM STACKED IN TERMS OF GRANULARITY - HOW MANY FIT IN THE .N FROM THE OTHERS

IF .N = ONE OF THE COUNTS, 

tract   sex   end_age by 3  race  ethnicity  - something about that adds potential for the matching on specs...

geoid   sex   end_age by 3

have them ordered by more specific to more general, then fill up as they know - whatever the smallest number is?
fcase(.N<bg_sa_count,fcase(.N<bg_se_count))





```{r test for completeness and symmetry with households and full population}
test <- table(
  tr_r_gq_over17[,tract],
  tr_r_gq_over17[,sex],
  tr_r_gq_over17[,institutionalized],
  tr_r_gq_over17[,gq_type]
)==table(
  bggq[age_range!="Under 18 years",tract],
  bggq[age_range!="Under 18 years",sex],
  bggq[age_range!="Under 18 years",institutionalized],
  bggq[age_range!="Under 18 years",gq_type]
)
length(test[test==FALSE])==0
```


OR: COULD JUST DO THE TRIANGLES AGAIN, AND THINK ABOUT WHAT IT MEANS TO ALLOW THE RACE, ETC., TO CHANGE WITH MORE INFORMATION AS IT GOES AROUND???

Let's create an indexed count by cell, given what we know, and then do a reduction to the smallest counts, then uncount

Or maybe: the total by cell from the right should be divided by total by cell from the left? - that loses information about the relative differences
If you order them by the left adjoint, 

```{r testing lists}
tr_sa_gq[, #have to see if it's following an internal order - explicitly doing it doesn't seem to change it... 
            ("gq_spec_list_count_sa"):=
              paste0(.N,"!_!",tract,"!_!",sex,"!_!",age_range,"!_!",institutionalized,"!_!",gq_type,"!_!",gq_specs),
            by=c("tract","sex","age_range","institutionalized","gq_type","gq_specs")]
tr_sa_gq[333,strsplit(gq_spec_list_count_sa,"!_!")][4]=="Under 18 years"
tr_sa_gq[333,strsplit(gq_spec_list_count_sa,"!_!")][1]=="8"
max(as.numeric(tr_sa_gq[,strsplit(gq_spec_list_count_sa,"!_!")][1]))
tr_sa_gq[444:446,strsplit(gq_spec_list_count_sa,"!_!")][1:4]
```

```{r add gq_spec_count_sa to over 17 gq from tr_sa_gq}
tr_sa_gq[, #have to see if it's following an internal order - explicitly doing it doesn't seem to change it... 
            ("gq_spec_count_sa"):=.N,
            by=c("tract","sex","age_range","institutionalized","gq_type","gq_specs")]
tr_r_gq_over17[,("bg_sa_gq_17_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_sa_gq[age_range!="Under 18 years",("bg_sa_gq_17_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_r_gq_over17[,("gq_spec_count_sa"):=
                    tr_sa_gq[.SD, list(gq_spec_count_sa), on = .(bg_sa_gq_17_match_id)]]
#tests
nrow(tr_r_gq_over17[is.na(gq_spec_count_sa)])==0
test <- summary(tr_sa_gq[age_range!="Under 18 years",gq_spec_count_sa])==
  summary(tr_r_gq_over17[,gq_spec_count_sa])
length(test[test==FALSE])==0
```

If you have sa spec count, and you assign every row before .N to the value from the sa, and after to "no_match", 


```{r add gq_spec_count_r and gq_spec_count_e to over 17 gq from tr_r_gq and tr_e_gq}
tr_r_gq[order(tract,re_code,institutionalized,gq_type,gq_specs), #test to see what's needed
            ("gq_spec_count_r"):=.N,
            by=c("tract","re_code","institutionalized","gq_type","gq_specs")]
tr_r_gq_over17[,("bg_r_gq_17_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq[,("bg_r_gq_17_match_id"):=
                    paste0(tract,re_code,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_type)]
tr_r_gq_over17[,("gq_spec_count_r"):=
                    tr_r_gq[.SD, list(gq_spec_count_r), on = .(bg_r_gq_17_match_id)]]
#tests
nrow(tr_r_gq_over17[is.na(gq_spec_count_r)])==0
test <- summary(tr_r_gq[,gq_spec_count_r])==
  summary(tr_r_gq_over17[,gq_spec_count_r])
length(test[test==FALSE])==0
```

Once it has both spec totals, how do we multiply possible combinations and assign?

If we take the one that already has sex and race and order it that way, and int.seq up to ...



REDOING!!!

#also do a spec count from tr_r to bggq; then the specifics can be used to ground the triangles

```{r add gq_spec_count_r to bggq from tr_r_gq}
tr_r_gq[,("gq_spec_count_r"):=.N,by=c("tract","race","institutionalized","gq_type","gq_specs")]
bggq[,("bg_r_gq_match_id"):=
                    paste0(tract,race,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,race,gq_type)]
tr_r_gq[,("bg_r_gq_match_id"):=
                    paste0(tract,sex,age_range,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range,gq_type)]
bggq[,("gq_spec_count_r"):=
                    tr_r_gq[.SD, list(gq_spec_count_r), on = .(bg_r_gq_match_id)]]
#tests
nrow(bggq[is.na(gq_spec_count_r)])==0
test <- summary(bggq[,gq_spec_count_r])==
  summary(tr_sa_gq[,gq_spec_count_r])
length(test[test==FALSE])==0
```
#then will just have 

Joining PCT20 and PCT22, since they have the same race, ethnicity, and group quarters type. PCT22 is for age over 17 only, but the under 18 group is relatively small (1,927, which is less than 5%). After doing the joins on race, we'll be able to replicate a version by ethnicity, which will help determine the main table's missing ethnicity values.

Let's quickly ensure that the variables we want to match on are written the same way for each table. (We had to fix this, and did so silently, above, because of some idiosyncratic capitalization)
```{r unique on variable tags for tr_r_gq and over17}
#test to ensure matching variables match
test <- unique(tr_r_gq[order(institutionalized),institutionalized])==
  unique(tr_r_gq_over17[order(institutionalized),institutionalized])
length(test[test==FALSE])==0
test <- unique(tr_r_gq[order(gq_type),gq_type])==
  unique(tr_r_gq_over17[order(gq_type),gq_type])
length(test[test==FALSE])==0
```
Have to add group quarter specifics to the over 17. 

```{r add gq_spec_count to bggq from tr_sa_gq}
tr_r_gq_over17[,("bg_sa_gq_17_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
bggq[age_range!="Under 18 years",("bg_sa_gq_17_match_id"):=
                    paste0(tract,sex,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type)]
tr_r_gq_over17[,("gq_specs"):=
                    bggq[.SD, list(gq_specs), on = .(bg_sa_gq_17_match_id)]]
#tests
nrow(tr_r_gq_over17[is.na(gq_specs)])==0
test <- table(
  tr_r_gq_over17[,tract],
  tr_r_gq_over17[,sex],
  tr_r_gq_over17[,institutionalized],
  tr_r_gq_over17[,gq_type],
  tr_r_gq_over17[,gq_specs]
)==table(
  bggq[age_range!="Under 18 years",tract],
  bggq[age_range!="Under 18 years",sex],
  bggq[age_range!="Under 18 years",institutionalized],
  bggq[age_range!="Under 18 years",gq_type],
  bggq[age_range!="Under 18 years",tr_gq_specs]
)
length(test[test==FALSE])==0
```
START HERE!! - Problem is that this gets by race, and we had moved it earlier without race!!

Now that the matching variables are typed out correctly for the match - may just get rid of _count
```{r add sex and age_range (by opp to Under 18) to tr_r_gq from tr_r_gq_over17}
#tr_r_gq_over17[,("gq_s_a_type_count"):=.N,by=c("tract","re_code","institutionalized","gq_type")]
tr_r_gq_over17[,("tr_r_t_gq_match_id"):=
                    paste0(tract,re_code,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_specs)]
tr_r_gq[,("tr_r_t_gq_match_id"):=
                    paste0(tract,re_code,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,re_code,gq_specs)]
tr_r_gq[,c("sex"):=
                    tr_r_gq_over17[.SD, c(list(sex)), on = .(tr_r_t_gq_match_id)]]
tr_r_gq[is.na(sex),("age_range"):=.("Under 18 years")]
#tests
nrow(tr_r_gq[!is.na(sex)])==nrow(tr_r_gq_over17)
```
Determine sex and age range by matching on the tract level by group quarters type (tr_r_gq from bggq) and specifics (from bggq, put there from the sex and age range tables). There is some chance that the not under 18 age groups will not match by race, but no more detailed determinations are available for these subgroups. There will be some refinement as more specific ages are generated, below. 
[[not using the counts, yet]] 

```{r determine sex and age range on tr_r_gq}
#now we'll create matching ids with a conditional clause for age_range
#remember gq_s_a_type_count was by=c("tract","re_code","institutionalized","gq_type") 
tr_r_gq[is.na(age_range),("trgqsa_match_id"):=
             paste0(tract,institutionalized,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,institutionalized,gq_type,gq_specs)]
bggq[age_range!="Under 18 years",("trgqsa_match_id"):=
                    paste0(tract,institutionalized,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,institutionalized,gq_type,gq_specs)]
tr_r_gq[is.na(age_range),c("sex","age_range"):=
                    bggq[.SD, c(list(sex),list(age_range)), on = .(trgqsa_match_id)]]
#that should make all the age_range complete on tr_r, with the Under18 not having sex assigned.
nrow(tr_r_gq[is.na(sex)])==nrow(bggq[age_range=="Under 18 years"])
#so just add the last 1,927 sex for under18
tr_r_gq[is.na(sex),("trgqs_match_id"):=
             paste0(tract,age_range,institutionalized,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,age_range,institutionalized,gq_type,gq_specs)]
bggq[age_range=="Under 18 years",("trgqs_match_id"):=
                    paste0(tract,age_range,institutionalized,gq_type,gq_specs,as.character(100000+sample(1:.N))),
                  by=.(tract,age_range,institutionalized,gq_type,gq_specs)]
tr_r_gq[is.na(sex),c("sex"):=
                    bggq[.SD, c(list(sex)), on = .(trgqs_match_id)]]
#tests
nrow(tr_r_gq[is.na(sex)])==0
test <- table(
  tr_r_gq$tract,
  tr_r_gq$sex,
  tr_r_gq$age_range,
  tr_r_gq$institutionalized,
  tr_r_gq$gq_type,
  tr_r_gq$gq_specs
)==table(
  bggq$tract,
  bggq$sex,
  bggq$age_range,
  bggq$institutionalized,
  bggq$gq_type,
  bggq$gq_specs
)
length(test[test==FALSE])==0
```

Now let's put group quarter race on to bggq from the tract level race group quarters. It's really just filling out the relations that have already been established - closing the commutative relations. The steps that add ethnicity are the last before joining and moving up to the next level with households and the entire population.

```{r determine group quarter specifics on bggq}
#now we'll create matching ids with a conditional clause for age_range
#remember gq_s_a_type_count was by=c("tract","re_code","institutionalized","gq_type") 
tr_r_gq[,("trgqr_match_id"):=
             paste0(tract,institutionalized,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,institutionalized,gq_type)]
bggq[,("trgqr_match_id"):=
                    paste0(tract,institutionalized,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,institutionalized,gq_type)]
bggq[,c("sex","age_range"):=
                    tr_r_gq[.SD, c(list(sex),list(age_range)), on = .(trgqr_match_id)]]


#that should make all the age_range complete on tr_r, with the Under18 not having sex assigned.
nrow(tr_r_gq[is.na(sex)])==nrow(bggq[age_range=="Under 18 years"])
#so just add the last 1,927 sex for under18
tr_r_gq[is.na(sex),("trgqs_match_id"):=
             paste0(tract,age_range,institutionalized,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,age_range,institutionalized,gq_type)]
bggq[age_range=="Under 18 years",("trgqs_match_id"):=
                    paste0(tract,age_range,institutionalized,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,age_range,institutionalized,gq_type)]
tr_r_gq[is.na(sex),c("sex"):=
                    bggq[.SD, c(list(sex)), on = .(trgqs_match_id)]]
#tests
nrow(tr_r_gq[is.na(sex)])==0
test <- table(
  tr_r_gq$tract,
  tr_r_gq$sex,
  tr_r_gq$age_range,
  tr_r_gq$institutionalized,
  tr_r_gq$gq_type,
  tr_r_gq$gq_specs
)==table(
  bggq$tract,
  bggq$sex,
  bggq$age_range,
  bggq$institutionalized,
  bggq$gq_type,
  bggq$gq_specs
)
length(test[test==FALSE])==0
```
Do the ethnicity triangles for what had just been the race triangles??

Now we have all the possible specifications for adding race at the tract level to the block level - think about how that relates to the _initial???



```{r add gq_race_count to bggq from tr_r_gq}
tr_r_gq[,("gq_race_count_type"):=.N,by=c("tract","race","institutionalized","gq_type")]
tr_r_gq[,("gq_race_count_spec"):=.N,by=c("tract","race","institutionalized","gq_type","gq_specs")]
bggq[,("bg_r_gq_match_id"):=
                    paste0(tract,sex,age_range,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,age_range)]
tr_sa_gq[,("bg_r_gq_match_id"):=
                    paste0(tract,sex,gq_type,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,age_range)]
bggq[,c("gq_race_count_type","gq_race_count_spec"):=
                    tr_sa_gq[.SD, c(list(gq_race_count_type),list(gq_race_count_spec)), on = .(bg_r_gq_match_id)]]
#tests

```


```{r add gq_spec_count to bggq from tr_sa_gq}
tr_sa_gq[,("gq_spec_count"):=.N,by=c("tract","sex","age_range","institutionalized","gq_type","gq_specs")]
bggq[,("bg_sa_gq_match_id"):=
                    paste0(tract,sex,age_range,gq_type,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,age_range)]
tr_sa_gq[,("bg_sa_gq_match_id"):=
                    paste0(tract,sex,gq_type,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,gq_type,age_range)]
bggq[,("gq_spec_count"):=
                    tr_sa_gq[.SD, list(gq_spec_count), on = .(bg_sa_gq_match_id)]]
#tests

```

THEN put the remains stuff on to the _initial table on tract and solve... the nested fcases...
THEN put the _initial back to bgSAR

Here, we'll use the conditional clauses to determine the dependent types. [[may be worth a longer exegesis]]

##Some of this may be recap from the ACS_probs Rmd - have to think about the structure of the overall argument and whether to try to recap here.
At this point, we have several options, all of which we can characterize in terms of the types of structures preserved by the different approaches. If we think of every way of talking about the representation as an object, and our task as being about how we understand the various constructions of representations, then we are being guided by the demand for an overall coherence in our representation and not by the connection between our representation and a set of objects at a particular point. There are philosophical reasons to justify that choice - after all, the connection between our representation and the set of objects would, in every particular case, also have to be a representation, so being guided by the coherence of the ensemble of representations gives you a more encompassing overall approach. That turn toward the coherence of the representation need not be a turn toward relativism, however, even though it deliberately celebrates the proliferation of modes of representation. Ordinary high school mathematics can be a guide here; as you transform an algebra problem, following rules for reshaping each side of the equation, you're dealing with the coherence of the representations and looking for a particular form - or mathematical object - that helps resolve the equations into something more useful. On the other side, one is tempted by the idea that each transformation should be tied to a determination or judgment about the connection of the world to the proposition or sets of propositions being made. 
In the latter case, for example, one would approach the reconstruction of census data with an eye toward maintaining throughout all the representations the statistical likelihood that any particular representation would be correctly reflected by the ground truth at that step. You would, in our particular conundrum, choose either race, ethnicity, age, sex, or geography (or some known combination of them) to set as a base and then add the other attributes step-wise while tracking the statistical uncertainty introduced. This could be relatively detailed, and derived from the same dataset:

```{r solving race eth statistically}
#create percentages of people in each tract who are there by age or by race, 
#or by race, ethnicity, and age - one can go down in the cells to a very detailed level
#code snippet

#create each individual by saying they have that percentage chance to be 
#in each of the boxes at that level.
#code snippet

#see the totals diverge in the way that leads us to the ACS unusability - 
#where the confidence interval makes some sense at the highest level, i.e., 
#at the tract by age_range, but stops being realistic as that range is 
#further spread out when projecting below that level into block_groups or 
#more specific ages
#code snippet
```

In our way of speaking, what that approach does is privilege the structure of the individual confronting an unknown distribution of objects and asking whether that distribution falls within an expected range. We are not questioning the legitimacy of that statistical question, but we are asking what it means to privilege other structures of coherence. Another way of thinking about the problem is to say that the statistical estimation is the place where the encoding of the functions is projected onto the place where an individual subject looks at some particular distribution and describes its embeddedness in another level of an individual subject looking at a distribution describing it - I know what percent by race live in the tract, so I can use that percentage to give an estimation at the block_group level. 

The problem with that set of presuppositions is that it sees the function of assigning characteristics to individuals as a projection of sets and then looks for the coherence in terms of comparing the distributions in the sets. One can make a judgment about whether the assigning function is effective or not, by looking at the outcomes as either being within acceptable distributions as determined by comparison with another set's output, but one is not taking advantage of the way the functions work as an ensemble of potential representations, allowing intermediate steps which conserve other elements of the relations, for example, before we get to the place where the statistical estimation is the right framework for judging efficacity. Treating the ensemble of mappings as a mathematical object is what it means, mathematically, to move from looking at the rules for producing a representation (for example, the arithmetic operations on a collection of objects) and asking whether the rules were correctly applied to looking at the way different rules for producing the same representation cohere and using the tools from the various mappings to move back and forth between operations until a more effective representation can be implemented (for example, solving a problem algebraically by working through the abstract possibilities of the combinations of variables until necessary structures for their possible combination become evident and can be employed to create a solution).  

We look to the household data to see if there's a way to help with understanding how to assign the Hispanic or Latino designation. What we will find is that there is a distribution of householders by race, a distribution of all the population in the households, and a distribution of all adults over 18 in the households, all by block_group. If we conserve the structures of relations between these designations by noting that there is a single distribution stored at the census that has each individual with all characteristics (within the range of problems they have with the initial collection), what we see are clues to the construction of each representation from the full set of characterized individuals to the particular subset produced in the tables. 

As we mentioned in passing, before, the function of subsetting is conceived differently for dependent type theory than for set theory. Does type theory let us think all the way to adjointness or is that the category theory? What I'm trying to take advantage of is triangle relations that are articulated at different levels and so aren't immediately commutative - but must happen within an overall space where an effective commutativity did exist (their representation, on their protected server, of the entire population). Could draw that in a diagram, but the point is that the commutativity is the first "algebraic" structure to maintain, as opposed to the representability of each produced representation in terms of its statistical relations to the whole (with its troubled attempt to guide its development by tracking the growing levels of uncertainty) - again, have to think about how much of this is already in ACS_probs.

We start with P28 because it captures the relation between race eth hhtype and hhsize. The others have more specificity to add to each.
We'll do this in the next in making_sam_avgs.Rmd (where we go through an illustrative example) and making_sam_hh.Rmd, for more effective computation, and save the block_group data, for use later.

```{r save bgSAR Harris csv}
#need to check if exists and replace, if needed
file_path <- valid_file_path(censusdir,vintage="2010",state,api_type="dec/sf1",block="block_group",groupname="bgSAR_Harris",path_suff="wrk.csv")
if(file.exists(file_path))
  {file.remove(file_path)}
write_csv(bgSAR,file_path)
```




Figure out how to insert, above:

If we add households to group quarters, we get the totals. 




The redistricting data collected in 2010 reports population estimates in yet a different format. It has one table that has races and ethnicity data for everyone over 18 and one that has it for everyone, with no ages attached. The race data gives more details on the composition of "Two or More Races" but nothing else new. The ethnicity file gives block level data for Hispanic or Latino who don't identify as White. Gives slightly more contour, but not much, and risks big differences on age and ethnicity or race per block group. (Although some contour is better than none!)

```{r pl data downloaded}
    eth_block_data_from_census <- censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                                                                      groupname = "P2",county_num = county,
                                                                      block="block_group",api_type="dec/pl",path_suff="est.csv")
    race_block_data_from_census <- censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                                                                groupname = "P1",county_num = county,
                                                                block="block_group",api_type="dec/pl",path_suff="est.csv")
    eth_over17_block_data_from_census <- censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                                                                      groupname = "P4",county_num = county,
                                                                      block="block_group",api_type="dec/pl",path_suff="est.csv")
    race_over17_block_data_from_census <- censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                                                                groupname = "P3",county_num = county,
                                                                block="block_group",api_type="dec/pl",path_suff="est.csv")
 
    
```



Just because of how limitations work on computer memory, let's save the modified SAR data. 
```{r save SAR Harris csv}
#    file_path <- valid_file_path(censusdir,vintage="2010",state,api_type="dec/sf1",block="tract",groupname="SAR_Harris",path_suff="wrk.csv")
#    write_csv(SAR,file_path)
```

NOT USED???


```{r matching chunk example}

#and for Hispanic, will put a tmp_ethnicity, knowing that the bgSAR is more complete
trHHr[is.na(ethnicity),("trHHsae1_match_id"):=
                    paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHe[ethnicity=="H",("trHHsae1_match_id"):=
                    paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHr[is.na(ethnicity),("tmp_ethnicity"):=
                    trHHe[.SD, list(ethnicity), on = .(trHHsae1_match_id)]]
nrow(trHHr[!is.na(tmp_ethnicity)])==nrow(trHHe[ethnicity=="H"])
test <- table(trHHr[!is.na(tmp_ethnicity),tract],
              trHHr[!is.na(tmp_ethnicity),sex],
              trHHr[!is.na(tmp_ethnicity),age_range],
              trHHr[!is.na(tmp_ethnicity),tmp_ethnicity]
) == table(
  trHHe[ethnicity=="H",tract],
  trHHe[ethnicity=="H",sex],
  trHHe[ethnicity=="H",age_range],
  trHHe[ethnicity=="H",ethnicity]
)
length(test[test==FALSE])==0

```




```{r get structure from bgSAR to add rows to trHHr}
#on this one, doing a left join is the fastest way to expand; it does a couple of unexpected things that we can deal with
bgSAR_initial <- bgSAR[,c("tract","race","ethnicity","sex","age_range","first_age","last_age")]
trHHr <- trHHr[bgSAR_initial, on=.(tract,race,ethnicity,sex,age_range,first_age,last_age)]
nrow(trHHr)==nrow(bgSAR)
test <- table(trHHr[,tract],
              trHHr[,race],
              trHHr[,sex],
              trHHr[,age_range]
) == table(
  bgSAR[,tract],
  bgSAR[,race],
  bgSAR[,sex],
  bgSAR[,age_range]
)
length(test[test==FALSE])==0
test <- table(trHHr[race=="A",tract],
              trHHr[race=="A",ethnicity],
              trHHr[race=="A",sex],
              trHHr[race=="A",age_range]
) == table(
  bgSAR[race=="A",tract],
  bgSAR[race=="A",ethnicity],
  bgSAR[race=="A",sex],
  bgSAR[race=="A",age_range]
)
length(test[test==FALSE])==0
```
Let's begin by calculating how many non-White individuals should be listed as Hispanic householders, and how many as Hispanic or Latino in group quarters.
Should draw the below as a diagram:
START HERE SLOWLY - IS THE INITIAL NEEDED??? MAY GET RID OF ALL _COUNT and not use initial at all!!

```{r move num_eth over to tract level household}
#then do num_eth_A on r, and then join for the num_eth totals from e [should equal the Hs]; then subtract for num_H_remain
trHHr_initial[,("num_eth_A_hh") := .N, by = c("sex","age_range","ethnicity","tract")]
trHHr_initial[,("trHHsae2_match_id"):=
                    paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHe[,("trHHsae2_match_id"):=
                    paste0(tract,sex,age_range,as.character(100000+sample(1:.N))),
                  by=.(tract,sex,age_range)]
trHHr_initial[,("num_eth_hh"):=
                    trHHe[.SD, list(num_eth), on = .(trHHsae2_match_id)]]
trHHr_initial[,("num_H_remain_hh"):=num_eth_hh - num_eth_A_hh]
#somehow, need num_H_remain_gq to be by right subcategories for .N to make sense...
#trHHr_initial[,("num_H_remain"):=num_H_remain_hh+num_H_remain_gq (but need to do stuff for race=="A"on gq)]
#think about what is left
#summary(trHHr[race!="A",num_H_remain])
```

