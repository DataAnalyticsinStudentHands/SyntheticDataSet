---
title: "Making Sam Households"
author: "Dan Price"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
geometry: margin=1in
fontsize: 11pt
documentclass: article
header-includes: 
  - \usepackage{tikz}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Preliminaries -- very broad
https://kbroman.org/knitr_knutshell/pages/Rmarkdown.html for options on the knit - results="hide"; echo=FALSE; include=FALSE, etc.

```{r prelims}
source('BaseScripts/Census_Data.R') #move out of BaseScripts?
source('tests.R')
library(tidyr)
library(dplyr)
library(stringr)
library(data.table)
#maindir = "~/University Of Houston/Price, Daniel M - Social Network Hypergraphs/"
maindir = "~/Downloads/UH_OneDrive/OneDrive\ -\ University\ Of\ Houston/Social\ Network\ Hypergraphs/" #Dan at home
#maindir = "~/Downloads/OneDrive\ -\ University\ Of\ Houston/Social\ Network\ Hypergraphs/" #Dan at work
housingdir = paste0(maindir,"HCAD/")
houstondatadir = paste0(maindir,"HoustonCityData/") 
censusdir = paste0(maindir,"Census/") 
vintage = "2019"
housingStockFromRDS = TRUE 
#numberOfCores = 1
state = 48 #48 Texas; 22 Louisiana
county = 201 #8 county region: 201 Harris; 157 Fort Bend; 167 Galveston; 039 Brazoria; 071 Chambers; 291 Liberty; 339 Montgomery; 473 Waller ; other place FIPS are longer
tract = "*"
Sam_seed = 135
#you don't need a censuskey if you're not pulling new files down; you can only use this one if you have correct access to the OneDrive
censuskey <- readLines(paste0(censusdir, "2017", "/key"))
```


For new file, and need a bit of a preamble

[this is what's also in making_sam_avgs.Rmd]
We're going to begin with the 2010 block group data table, P28 - "Household Type by Household Size" (by Race and Ethnicity). We start here not because it provides the greatest granularity, although it is by block group and is the most granular data available for these tables, but because P28 has the best _structured_ relationality, around which commutative triangles can be built. The longer idea is to see the census bureau's copy of the full data representation as being both perfectly commutable in the ways it can be represented and granular at an individual level (again, setting aside difficulties with their collection and category choice in order to concentrate on the choices made that give structure to the whole). There are then ways in which the census bureau produces tables, with different concerns at different stages and with different products, but the statisticians at the Census Bureau both try to ensure the structure of commutability is maintained within the particular representation and to ensure that the people interpreting the data understand how it relates statistically as a subset - which is to say, how the granularity of the presentation is related to the underlying granularity as the chance that when you see someone from a particular subset, the individuals in that subset fit into the demographics of the larger group. [that could be better phrased, but trying to get at difference between set theory and type theory with the categorical spin]


We could approach the next steps in the building process in a couple of ways. One would be to look at the other census tables (or other sources of information or intuition) to try to create a statistical model and then use the sample on the individual cells with a statistical probability assigned. We are, in fact, using the sample function, but with a sense of their being an explicit construction of the possible answers that still determine the deployment. In the R implementation, it's just to say its sample with "replace=False". (Can talk a bit about how the information at the block group level allows this to be a specification without knowing everything involved in making the block groups be determinative of outcomes.) 

We keep looking for relations that are more fundamental - not in the sense that they cause others, but that they represent the possibilities inherent in the structure of the overall representation. Things like sex, race, ethnicity, and age are fundamental because they show up in lots of the data tables put out by the census, and they have ensured that they are complete and commutative between representations at multiple levels. We're trying to show that we can use those relations to create better representations than just the tables by themselves would allow, and thus to make a larger point about how the construction of data problems and answers move hand in hand. 
In summary, if you try to build the representation piece by piece, while insisting on the structure of how certain you are of the particular step, you are both leaving behind the strength of the relationships in building a coherent representation and forgetting that the relations imply certain sorts of structures - have to work on that phrasing.

For our point, what we're saying is that the relations as structures are represented by triangle commutativity. In practice, that just means that we build the data set by adding where we have some way of maintaining the structure needed to make it meaningful. The basic unit of interest is the relation, and then the way that the whole sets of relations are set out is what's of interest in our mapping. If we think of it as just adding attributes to the individual, including their relations, then the chance of it all building into one are limited - it's why there's more margin of error as you get smaller for the census.

GO THROUGH AND DRAW

#Relations and representation

As we did in the example about the averages, let's download P28, "Household Type by Household Size" (by Race and Ethnicity) and this time work with it at more length, and with the idea that the structuring of a space within which the answers to a problem can be understood as having _fit_ is part of the generalizable insight we want to pursue. That the sense of fit is itself built from an understanding of how relations structure individuality, and not how relations attach to individuals as properties, justifies are general approach to rebuilding from the census tables. But we'll try to let that unfold as we go.

```{r download hhtype hhsize race eth bg}
dec_bgHH_type_size_re_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "P28",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_data_10 <- as.data.table(dec_bgHH_type_size_re_data_from_census_10) 
```

Then do our basic checks:
```{r hh_type_size_re test problems}
check_summary <- census_table_check(dec_bgHH_data_10, "HOUSEHOLD TYPE BY HOUSEHOLD SIZE","households") #should get a function that fails appropriately
cat(check_summary[1])
```

Now we need to convert the census representation into a representation of individual households (move from a wide to a long table format).

```{r expand P28 into dec_bgHHr_10 and dec_bgHHe_10}
    #break into race and ethnicity files
    race_codes <- c("A","B","C","D","E","F","G")
    dec_bgHHr_10 <- dec_bgHH_data_10 %>%
      pivot_longer(4:ncol(dec_bgHH_data_10),names_to = "geoid", values_to = "number_sams") %>% 
      mutate(
        race = substr(name,5,5),
        race_text = tolower(str_extract(concept, "(?<=\\().*(?=\\))")),
        race_text = str_remove_all(race_text," householder"),
        label = str_remove_all(label,"Total!!")) %>%
      filter(label != "Total") %>% #keep only the ones that aren't aggregated
      separate(label, c("family","hh_size"), sep = "!!", remove = F, convert = FALSE) %>%
      mutate(hh_size_n = as.numeric(substr(hh_size,1,1))) %>%
      filter(!is.na(hh_size) & race%in%race_codes) %>% #to get rid of aggregations by family
      uncount(number_sams,.id = "hhr_size_id",.remove = TRUE) 
    dec_bgHHr_10 <- as.data.table(dec_bgHHr_10) #dyplyr had stripped it of dt
    paste0("Number of households in file: ", nrow(dec_bgHHr_10))
    print("Column names for dec_bgHHr_10, block group households by race:") 
    colnames(dec_bgHHr_10)
    
    #and same for ethnicity
    dec_bgHHe_10 <- dec_bgHH_data_10 %>%
      pivot_longer(4:ncol(dec_bgHH_data_10),names_to = "geoid", values_to = "number_sams") %>% 
      mutate(
        ethnicity = substr(name,5,5),
        label = str_remove_all(label,"Total!!")) %>%
      filter(label != "Total") %>% #keep only the ones that aren't aggregated
      separate(label, c("family","hh_size"), sep = "!!", remove = F, convert = FALSE) %>%
      mutate(hh_size_n = as.numeric(substr(hh_size,1,1))) %>%
      filter(!is.na(hh_size) & ethnicity%in%c("H","I")) %>% 
      uncount(number_sams,.id = "hhe_size_id",.remove = TRUE) 
    dec_bgHHe_10 <- as.data.table(dec_bgHHe_10) #dyplyr had stripped it of dt
    paste0("Number of households with ethnicity attributes in file: ", nrow(dec_bgHHe_10))
    print("Column names for dec_bgHHe_10, block group households by ethnicity:") 
    colnames(dec_bgHHe_10)
    #clean up
    rm(dec_bgHH_data_10)
    rm(dec_bgHH_type_size_re_data_from_census_10)
    
```


#Triangle Commutativity.

Could talk about history of Symmetric Monoidal Categories (SMCs), and how they are based in that original thought about triangles and enabling algebraic structures like commutativity. Could also do a diagram or two here. We're talking about a concrete representation of the relations as structuring individual emergence, but can't get too far into the philosophical language.

In many ways, this example is very simple. What happens is that we have P28, which already has type and size along with race and ethnicity. Then P18 has household type by race and ethnicity, but has more details on type - some of which should be reflected in the size. The strategy for disposition of the individuals into the appropriate categories takes advantage of how subsetting works in R's data.table package, but the final representation will work better by virtue of a second step that allocates the categories by available spaces, and not by the abstract likelihood of being in a space at all. This is meant to point at our way of thinking about structuring spaces - both in terms of a neighborhood effecting life outcomes and as a space that precedes and condition a product of a function. This should show how the overall approach breaks with the idea of set theory and moves to dependent types, algebraic structures on spaces, and strengths-based analysis of dynamic and emergent properties. The arithmetic is simple, and many of the choices can be motivated within set theory, but we hope to show a few places where that would not hold. 

Now let's get P18, household type by race and ethnicity, which has more detail in the type of household, so that we can look carefully at how to construct a representation of that household that respects the original relational structure. Race and ethnicity give us rich possibilities relationally because the tables both capture relations in terms of a shared category, but also because they produce two parallel tables, one for race and one for ethnicity, which overlap in ways that carry significant structure in terms of other relations of interest.

```{r download hhtype P18 race eth bg}
dec_bgHH_type_re_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "P18",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_type_data_10 <- as.data.table(dec_bgHH_type_re_data_from_census_10)
```

Then do our basic checks:
```{r hh_type_re test problems}
#pain in the butt how they reported on their subtotals!!
check_summary <- census_table_check(dec_bgHH_type_data_10[substr(name,5,5)!="H" & 
                  substr(name,5,5)!="I" & 
                    label!="Total!!Family households!!Other family"], 
                  "HOUSEHOLD TYPE","households") 
cat(check_summary[1])
```

Then expand into the representation of individual households by both ethnicity and race. 

```{r expand P18 into dec_bgHH_type_10}
#break into race and ethnicity files
    race_codes <- c("A","B","C","D","E","F","G")
    dec_bgHHr_type_10 <- dec_bgHH_type_data_10 %>%
      pivot_longer(4:ncol(dec_bgHH_type_data_10),names_to = "geoid", values_to = "number_sams") %>% 
      mutate(
        race = substr(name,5,5),
        label = str_remove_all(label,"Total!!"),
        label = str_remove_all(label,"!!Other family")) %>%
      filter(label != "Total") %>% #keep only the ones that aren't aggregated
      separate(label, c("family","family_details"), sep = "!!", remove = F, convert = FALSE) %>%
      filter(!is.na(family_details) & race%in%race_codes) %>% #to get rid of aggregations by family
      uncount(number_sams,.id = "hhr_type_id",.remove = TRUE) 
    dec_bgHHr_type_10 <- as.data.table(dec_bgHHr_type_10) #dyplyr had stripped it of dt
    paste0("Number of households in file: ", nrow(dec_bgHHr_type_10))
    nrow(dec_bgHHr_10)==nrow(dec_bgHHr_type_10)
    #dec_bgHHr_type_10[,4:ncol(dec_bgHHr_type_10)] <- dec_bgHHr_type_10[,lapply(.SD[,4:ncol(dec_bgHHr_type_10)], as.numeric)]
    
    #and same for ethnicity
    dec_bgHHe_type_10 <- dec_bgHH_type_data_10 %>%
      mutate(
        ethnicity = substr(name,5,5),
        label = str_remove_all(label,"Total!!"),
        label = str_remove_all(label,"!!Other family")) %>%
      filter(label != "Total") %>% #keep only the ones that aren't aggregated
      pivot_longer(4:ncol(dec_bgHH_type_data_10),names_to = "geoid", values_to = "number_sams") %>% 
      separate(label, c("family","family_details"), sep = "!!", remove = F, convert = FALSE) %>%
      filter(!is.na(family_details) & ethnicity%in%c("H","I")) %>% 
      uncount(number_sams,.id = "hhe_type_id",.remove = TRUE) 
    dec_bgHHe_type_10 <- as.data.table(dec_bgHHe_type_10) #dyplyr had stripped it of dt
    paste0("Number of households with ethnicity attributes in file: ", nrow(dec_bgHHe_10))
    nrow(dec_bgHHe_10)==nrow(dec_bgHHe_type_10)
    #should clean up
    rm(dec_bgHH_type_data_10)
    rm(dec_bgHH_type_re_data_from_census_10)
```

```{r test tables for P28 and P18}
#test_result <- symmetry_test(dec_bgHHr_10,dec_bgHHr_tenure_10,c("geoid"),c("geoid"))
test <- table(dec_bgHHr_10[,geoid],
              dec_bgHHr_10[,family],
              dec_bgHHr_10[,race]
)==table(
  dec_bgHHr_type_10[,geoid],
  dec_bgHHr_type_10[,family],
  dec_bgHHr_type_10[,race]
)
length(test[test==F])==0
test <- table(dec_bgHHe_10[,geoid],
              dec_bgHHe_10[,family],
              dec_bgHHe_10[,ethnicity]
)==table(
  dec_bgHHe_type_10[,geoid],
  dec_bgHHe_type_10[,family],
  dec_bgHHe_type_10[,ethnicity]
)
length(test[test==F])==0
```

Here, we want to join one extra bit of information from the type data, which is whether folks live alone, or with others in a family (such as a married couple or single parent) or with others in a non-family relationship.
It's significant information, but very much correlates with the size relation and so shouldn't be added without making the appropriate adjustments. As we can see from the tables, below, there are the exact same number of householders living alone as one person households. This will give us an anchor for thinking about how to distribute the other household size numbers.

```{r table on family and family details}
table(dec_bgHHr_type_10$family_details,dec_bgHHr_type_10$family)
table(dec_bgHHr_10$hh_size)
nrow(dec_bgHHr_10[hh_size_n==1])==nrow(dec_bgHHr_type_10[family_details=="Householder living alone"])
```
We could run through it once with only the 361,888 householders who live alone listed from each side, and then match the others on a random sample, or something slightly more structured, if we have a sense of what the comparative shapes of the distributions are. Or we could generate a new number, following some reasoning about their relative shapes as justified by some exterior reasoning, that we then use for the sort. We'll do a bit of both. Following the approach we used on the average size, above, let's assign numbers based on family_detail, while also creating a specialized version of the if clause in R (fcase(hh_size_n==1,"1_person",default = "2or>_persons")) in the name for the matching. Then we'll test to ensure every household has been assigned an id. We'll use that same fcase to assign slightly skewed shapes to the other family_details categories, with the idea that we will return to these calculations and improve them later by iterating between the constructions on the production of the individuals and the shape of the structures that will receive the individuals into their relative categories. 

```{r assign numbers to family_detail matcher_id}
dec_bgHHr_10[,("one_match"):=fcase(hh_size_n==1,"1_person",default = "2or>_persons")]
dec_bgHHe_10[,("one_match"):=fcase(hh_size_n==1,"1_person",default = "2or>_persons")]
dec_bgHHr_type_10[,("one_match"):=fcase(family_details=="Householder living alone","1_person",default = "2or>_persons")]
dec_bgHHe_type_10[,("one_match"):=fcase(family_details=="Householder living alone","1_person",default = "2or>_persons")]
#table(dec_bgHHr_10$one_match)
#table(dec_bgHHr_type_10$one_match)
#table(dec_bgHHe_10$one_match)
#table(dec_bgHHe_type_10$one_match)
#can't seem to use .N inside of an equation inside sample to make the size responsive
dec_bgHHr_type_10[,("family_detail_matcher"):=.(fcase(
  family_details=="Householder living alone", sample(1:.N,.N,replace = FALSE),
  family_details=="Householder not living alone", sample(10:.N,.N,replace = TRUE),
  family_details=="Male householder, no wife present", sample(12:.N,.N,replace = TRUE),
  family_details=="Female householder, no husband present", sample(13:.N,.N,replace = TRUE),
  family_details=="Husband-wife family", sample(14:.N,.N,replace = TRUE)
)),by=.(geoid,family,one_match,race)]
dec_bgHHe_type_10[,("family_detail_matcher"):=.(fcase(
  family_details=="Householder living alone", sample(1:.N,.N,replace = FALSE),
  family_details=="Householder not living alone", sample(10:.N,.N,replace = TRUE),
  family_details=="Male householder, no wife present", sample(12:.N,.N,replace = TRUE),
  family_details=="Female householder, no husband present", sample(13:.N,.N,replace = TRUE),
  family_details=="Husband-wife family", sample(14:.N,.N,replace = TRUE)
)),by=.(geoid,family,one_match,ethnicity)]
nrow(dec_bgHHe_type_10[is.na(family_detail_matcher)])
nrow(dec_bgHHr_type_10[is.na(family_detail_matcher)])

```

```{r join hh_type using bgHH and bgHH with type family or non}
dec_bgHHr_10[order(hh_size_n),
             ("hh_family_match_id"):=
                    paste0(geoid,family,one_match,
                           race,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,one_match,race)]
dec_bgHHr_type_10[order(family_detail_matcher), 
                  ("hh_family_match_id"):=
                    paste0(geoid,family,one_match,race,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,one_match,race)]
dec_bgHHr_10[,("family_details"):=
                    dec_bgHHr_type_10[.SD, list(family_details), on = .(hh_family_match_id)]]
dec_bgHHe_10[order(hh_size_n),("hhe_family_match_id"):=
                    paste0(geoid,family,one_match,
                           ethnicity,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,one_match,ethnicity)]
dec_bgHHe_type_10[order(family_detail_matcher),
                  ("hhe_family_match_id"):=
                    paste0(geoid,family,one_match,ethnicity,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family,one_match,ethnicity)]
dec_bgHHe_10[,("family_details"):=
                    dec_bgHHe_type_10[.SD, list(family_details), on = .(hhe_family_match_id)]]
nrow(dec_bgHHr_10[is.na(family_details)])==0
nrow(dec_bgHHe_10[is.na(family_details)])==0
```

Now, although it is important that the symmetries are still working, as demonstrated simply by showing that the tables are still equal, we'll also want to revisit this later.
That we will then go back and shift this by race / eth on family types, revisiting what we did before...

Test whether type (family or non-family) is now reflected in the right way for the data.
```{r test tables expanded for P28 and P18}

test <- table(dec_bgHHr_10[,geoid],
              dec_bgHHr_10[,family],
              dec_bgHHr_10[,family_details],
              dec_bgHHr_10[,race]
)==table(
  dec_bgHHr_type_10[,geoid],
  dec_bgHHr_type_10[,family],
  dec_bgHHr_type_10[,family_details],
  dec_bgHHr_type_10[,race]
)
length(test[test==F])==0
test <- table(dec_bgHHe_10[,geoid],
              dec_bgHHe_10[,family],
              dec_bgHHe_10[,family_details],
              dec_bgHHe_10[,ethnicity]
)==table(
  dec_bgHHe_type_10[,geoid],
  dec_bgHHe_type_10[,family],
  dec_bgHHe_type_10[,family_details],
  dec_bgHHe_type_10[,ethnicity]
)
length(test[test==F])==0
```

Let's do a couple of other easy tests to look at the statistical structure, too. We want to ensure, for example, that all householders living alone are properly counted as a "1-person household."

```{r testing statistical structure of construction for family_details}
table(dec_bgHHr_10$family_details,dec_bgHHr_10$hh_size)
#should think up some more, and try different ways of thinking about how we had nudged the hh_size piece, above
```

```{r cleaning up after dec bgHH family construction}
#cleaning up - need to think through better

rm(dec_bgHHr_type_10)
rm(dec_bgHHe_type_10)
#have to think through when and where to rm()
#we are now at a place where the original label and concept information has been moved into their respective categories.
#keeping concept on dec_bgHHr_10 for one match lower
dec_bgHHr_10[,c("name","label","concept","one_match","hh_family_match_id","hhr_size_id"):=NULL]
paste0("column names for dec_bgHHr_10: ")
colnames(dec_bgHHr_10)
dec_bgHHe_10[,c("name","label","concept","one_match","hhe_family_match_id","hhe_size_id"):=NULL]
paste0("column names for dec_bgHHe_10: ")
colnames(dec_bgHHe_10)
```

It would be foolish to try to encapsulate all of statistical practice with one sweeping gesture, but it does seem safe to say that the more aware you are of the presuppositions that lie behind any given practice, the more likely you are to avoid bias and prejudice - as well as other forms of sloppy statistical thinking. What the last two examples were meant to show is that there are ways in which the statistical structures in simple ideas like "average" can and should be understood within the context of the space that it is projected onto (or constructed as an object within). Without getting into the deeper philosophical questions around constructivism (in its myriad and somewhat differing forms in math and epistemology), one notes that it's possible to become actively engaged with at least some of the contours that have shaped that space, and to dive into the reasons that the space has its current shape. 

What we've also tried to highlight is that there is a reason to think that attention to the relational components of the constructed representation will lead to better overall clarity, consistency, and computability. The first tool we started using was the commutative triangle, and we've already pointed to the fact that many mathematicians would recognize it as an informal symmetric monoidal category (SMC for short). When used appropriately, commutative triangles provide some other important tools for our purposes, and we'll try to slowly introduce them into - and motivate them by - the construction of Sam City. We're trying to ground the choices in a different horizon of questions - spaces and relations as structures within which individuals are placed and emerge as such. We oppose this to the old approach to construction - determining what counts as an individual (or aggregate of individuals) and adding relations (or dimensions or factors). We recognize that there are many sophisticated techniques for modifying the representations as individuals are constructed around ever more complicated embeddings within these multi-factorial and multi-dimensional spaces, and that there are internally valid methods to account for uncertainty, bias, and the propagation of such across the cells of a table. By pointing to the possibility of constructing the space from the relations by leveraging the structures of commutative triangles, we are saying that there are choices that descend from that first decision about whether you're looking at the relation or the individual. Those choices will then yield both advantages and disadvantages for the overall representation of that space, and provide differing types of visibility into the structure of the competing spaces and the ways that they embed individuals into descriptions.

This is to take a pretty straightforward intuition - i.e., that as cell sizes decrease, you know more about the likelihood that has to do with people inside that cell, as you might with Bayesian approaches to estimation - and to begin a more fulsome conversation about how the construction of mathematical objects, In such a discussion, we include all the models we have for describing the world and the statistical methods we use to evaluate those model. That they involve numerous choices made within pragmatic contexts does not, in itself, say anything about the ultimate ontological frame of epistemological questions. But it does point to the potential to become more aware of what we're doing when we construct an understanding and communicate it to others - and what happens when we try to support that communication with the tools of statistics and mathematics more broadly. Our task now is to go through a few more steps of the construction, and to think a bit more carefully about what we're doing, and why, when we attribute a set of characteristics to the citizens of Sam City.

#Endpoints, Terminal Objects, and Paths

One of our basic tools for constructing Sam City is using a relation as the unit that we add to, with the individual level (in this case a household) serving as an empty endpoint for the relation. So that a semantically meaningful sense of individuality only fully emerges in its robust character as more and more of the relations are pulled together and allowed to intersect in that otherwise empty space. [have to set up before - perhaps in acs_probs? - why a space is not a set] In the terms of symmetric monoidal categories, that endpoint is a terminal object, and it allows us to understand the point around which commutative triangle structures are found (or constructed), and to understand the algebraic possibilities that arise along with those constructions. By "algebraic" we only mean to introduce the idea of operations on a space, and begin with the simple idea of combination, as constrained by commutativity maintained at the triangle level. For the simplest commutative diagram, it's just that the path along one edge of the triangle, understood as an operation on how the objects are represented, is equivalent to another path that goes through a different operation, or combination of operations, where "equivalent" is determined by the endpoint being the same no matter which path one has taken. Although this is somewhat trivial in its initial formulation, it provides an understanding of what is "adjoint" within the overall representation and thus allows for better articulation of the construction of the representation. We will speak more to the specific aspects of something being adjoint in later sections.

In the simpler vein with which we are beginning, we turn to H16, "Tenure by Household Size" (by race and ethnicity), where tenure is either that the householders are renters or owners of their homes. Since the relations between household size and race and ethnicity are the same for each individual, we can build the city from the fact that both share an edge of a triangle, which is commutative at the type level of the household in this case. We are going to build a somewhat more complicated spatial structure, and at the end we'll talk briefly about why the symmetric monoidal categories provide greater clarity than imposing simplicial complexes (the geometric representation of repeated structures in space). [[include a diagram, with explanation - q.uiver lets you output tikz, and so handles the pdf; it can also be an html link, but I'm not sure what's best in this .Rmd]]

Let's download H16 and look at it for some clues to how to build the data representation with the right commutative structure. Very simply, if the relation between household size and race or ethnicity matches on both data tables, then we'll get the relationship from tenure to household type for free - without having introduced any uncertainty into the construction, at this point, although we'll have to ensure that there aren't illegitimate (or unaccounted for) steps in further building down the line. (do we need to include a diagram extension with the place where the error enters?) 


```{r download tenure hhsize race eth bg}
dec_bgHH_rent_size_re_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "H16",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_tenure_data_10 <- as.data.table(dec_bgHH_rent_size_re_data_from_census_10)
#make the numbers into numeric type - some operations won't work with either integer or character, although we could play with optimizing it
dec_bgHH_tenure_data_10[,4:ncol(dec_bgHH_tenure_data_10)] <- 
  dec_bgHH_tenure_data_10[,lapply(.SD[,4:ncol(dec_bgHH_tenure_data_10)], as.numeric)]
```

Then do our basic checks:
```{r household tenure size re test problems}
check_summary <- census_table_check(dec_bgHH_tenure_data_10, "TENURE BY HOUSEHOLD SIZE","households") #should get a function that fails appropriately
cat(check_summary[1])
```
And expand in a way that is very similar to what we did with household type and size by race and ethnicity. 

```{r expand H16 into dec_bgHH_tenure_10}
race_codes <- c("A","B","C","D","E","F","G")
dec_bgHHr_tenure_10 <- dec_bgHH_tenure_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_tenure_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(
    race = substr(name,5,5),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("tenure","hh_size"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(hh_size_n = as.numeric(substr(hh_size,1,1))) %>%
  filter(!is.na(hh_size) & race%in%race_codes) %>% #to get rid of aggregations by family
  uncount(number_sams,.id = "hhr_tenure_id",.remove = TRUE) 
dec_bgHHr_tenure_10 <- as.data.table(dec_bgHHr_tenure_10) #dyplyr had stripped it of dt
paste0("Number of households in file: ", nrow(dec_bgHHr_tenure_10))
nrow(dec_bgHHr_10)==nrow(dec_bgHHr_tenure_10)
#break into race and ethnicity files
#nrow(dec_bgHHr_tenure_10)==sum(hh_totals_bg[,])
#and same for ethnicity
dec_bgHHe_tenure_10 <- dec_bgHH_tenure_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_tenure_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(
    ethnicity = substr(name,5,5),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("tenure","hh_size"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(hh_size_n = as.numeric(substr(hh_size,1,1))) %>%
  filter(!is.na(hh_size) & ethnicity%in%c("H","I")) %>% 
  uncount(number_sams,.id = "hhe_tenure_id",.remove = TRUE) 
dec_bgHHe_tenure_10 <- as.data.table(dec_bgHHe_tenure_10) #dyplyr had stripped it of dt
paste0("Number of households with ethnicity attributes in file: ", nrow(dec_bgHHe_tenure_10))
nrow(dec_bgHHe_10)==nrow(dec_bgHHe_tenure_10)
#should clean up
rm(dec_bgHH_tenure_data_10)
rm(dec_bgHH_rent_size_re_data_from_census_10)
```

Before doing the join, let's simply see if the relations between household size and race and ethnicity are the same for both. Assuming it passes that test, then we can add tenure in, and test it by just seeing if the equalities hold around the triangle. We don't need to know anything else about the connection between tenure and household size to be confident in the next steps, since we have not added anything to the construction that isn't immediately deduced from the given structures in the tables. [draw diagram?]

```{r test tables for P28 and H16}
#test_result <- symmetry_test(dec_bgHHr_10,dec_bgHHr_tenure_10,c("geoid"),c("geoid"))
test <- table(dec_bgHHr_10[,geoid],
              dec_bgHHr_10[,hh_size_n],
              dec_bgHHr_10[,race]
)==table(
  dec_bgHHr_tenure_10[,geoid],
  dec_bgHHr_tenure_10[,hh_size_n],
  dec_bgHHr_tenure_10[,race]
)
length(test[test==F])==0
test <- table(dec_bgHHe_10[,geoid],
              dec_bgHHe_10[,hh_size_n],
              dec_bgHHe_10[,ethnicity]
)==table(
  dec_bgHHe_tenure_10[,geoid],
  dec_bgHHe_tenure_10[,hh_size_n],
  dec_bgHHe_tenure_10[,ethnicity]
)
length(test[test==F])==0
```

Let's simply add the tenure information onto the household type and size information, but with an eye toward comparing it with a process that builds the construction from the commutative triangles. The process is similar to what we did with the sex, age, and race/ethnicity files, where we were able to use age_range as part of the relation and add ethnicity back onto the individuals who had only race for the tract level. We are not losing information, because we are just constructing the table where there is a known overlap, such that we know the number of households in each table cell for race/ethnicity by household size and tenure. The operation on each of the edges, in other words, has been subsetting, and we haven't violated any of the algebraic rules for combination, although we are trying to be attentive to when that could happen, and to rigorously show what structure has or has not been faithfully included in the overall construction. In this example, P22 also had the relation to household type, and if we add the tenure status by only race / ethnicity and household size, we risk missing important correlations. Let's put the tenure status by household size in but remember that we may change it later, so we can better understand that difference, after building a more complete representation and trying to get a better idea of how to add tenure to the overall representation.

```{r join hh_type and tenure using bgHH and bgHH_tenure}
dec_bgHHr_10[,("hh_tenure_match_id"):=
                    paste0(geoid,race,as.character(hh_size_n),as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size_n)]
dec_bgHHr_tenure_10[,("hh_tenure_match_id"):=
                    paste0(geoid,race,as.character(hh_size_n),as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size_n)]
dec_bgHHr_10[,("tenure"):=
                    dec_bgHHr_tenure_10[.SD, list(tenure), on = .(hh_tenure_match_id)]]
nrow(dec_bgHHr_10[is.na(tenure)])==0

dec_bgHHe_10[,("hhe_tenure_match_id"):=
                    paste0(geoid,ethnicity,as.character(hh_size_n),as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,hh_size_n)]
dec_bgHHe_tenure_10[,("hhe_tenure_match_id"):=
                    paste0(geoid,ethnicity,as.character(hh_size_n),as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,hh_size_n)]
dec_bgHHe_10[,("tenure"):=
                    dec_bgHHe_tenure_10[.SD, list(tenure), on = .(hhe_tenure_match_id)]]
nrow(dec_bgHHe_10[is.na(tenure)])==0
```

Test whether tenure is now reflected in the right way for the data by producing the tables that encapsulate the symmetries we wish to maintain.

```{r test tables expanded for P28 and H16}
nrow(dec_bgHHr_10[is.na(tenure)])
test <- table(dec_bgHHr_10[,geoid],
              dec_bgHHr_10[,hh_size_n],
              dec_bgHHr_10[,race],
              dec_bgHHr_10[,tenure]
)==table(
  dec_bgHHr_tenure_10[,geoid],
  dec_bgHHr_tenure_10[,hh_size_n],
  dec_bgHHr_tenure_10[,race],
  dec_bgHHr_tenure_10[,tenure]
)
length(test[test==F])==0
nrow(dec_bgHHe_10[is.na(tenure)])
test <- table(dec_bgHHe_10[,geoid],
              dec_bgHHe_10[,hh_size_n],
              dec_bgHHe_10[,ethnicity],
              dec_bgHHe_10[,tenure]
)==table(
  dec_bgHHe_tenure_10[,geoid],
  dec_bgHHe_tenure_10[,hh_size_n],
  dec_bgHHe_tenure_10[,ethnicity],
  dec_bgHHe_tenure_10[,tenure]
)
length(test[test==F])==0
#have to think through when and where to rm()
dec_bgHHr_10[,c("hh_tenure_match_id"):=NULL]
paste0("column names for dec_bgHHr_10: ")
colnames(dec_bgHHr_10)
dec_bgHHe_10[,c("hhe_tenure_match_id"):=NULL]
paste0("column names for dec_bgHHe_10: ")
colnames(dec_bgHHe_10)
```

Let's do a few statistics on how that looks for other relations.
```{r displaying statistics as a baseline for tenure and hh join}
#need to think through with Ioannis
```

The Census Bureau produces some tables, such as H14 "Tenure by Race of Householder," that has no information that isn't also contained in other tables (in this case, the H16 table that we just used). In a complete mapping of the Census Bureau tables into Sam City, we would want to account for all the published tables in some way, but we will not document that at this time. 


#Specification Allows Individuals to Emerge into Structured Space

What we do want to show is the difference in construction where you build data sets in terms of the operations one can be certain of, and then do matching on more factors. So, instead of adding tenure by household size directly to the overall household representation, we'll build a household by tenure representation that includes both size and type, then join by both, for comparison. The Census Bureau doesn't provide a table that has tenure with household type by race and ethnicity, but they do have one by household type by age by race and ethnicity. That fact may allow us to build the representation through construction by specification - i.e., we're not adding predicates to the individual, but specifying the space within which the individuals are allowed to emerge. That this embodies the slogan from category theory that relations precede objects is one of the things we hope to show in the process of building this simulated population for Sam City.

Let's download P22, 2010 decennial block group level data by household type by age of householder, but without race and ethnicity.

```{r download household type (family or non) age bg}
dec_bgHH_type_age_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "P22",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_type_age_data_10 <- as.data.table(dec_bgHH_type_age_data_from_census_10)
dec_bgHH_type_age_data_10[,4:ncol(dec_bgHH_type_age_data_10)] <- 
  dec_bgHH_type_age_data_10[,lapply(.SD[,4:ncol(dec_bgHH_type_age_data_10)], as.numeric)]
```
Then do our basic checks:
```{r household type age test problems}
check_summary <- census_table_check(dec_bgHH_type_age_data_10, 
      "HOUSEHOLD TYPE BY AGE OF HOUSEHOLDER","households") 
cat(check_summary[1])
```

And flip the tables to long from wide.

```{r expand hhtype_age_hh type and age of householder}
dec_bgHH_type_age_hh_10 <- dec_bgHH_type_age_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_type_age_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("family","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(age_range = case_when(age_range=="Householder 85 years and over" ~ "Householder 85 to 99",
                               TRUE ~ age_range),
         beg_age_P22 = as.numeric(substr(age_range,13,14)),
         end_age_P22 = as.numeric(substr(age_range,19,20))) %>%
  filter(!is.na(age_range)) %>% 
  uncount(number_sams,.id = "hh_type_age_id",.remove = TRUE) 
dec_bgHH_type_age_hh_10 <- as.data.table(dec_bgHH_type_age_hh_10) #dyplyr had stripped it of dt
paste0("Number of households in file: ", nrow(dec_bgHH_type_age_hh_10))
test <- table(dec_bgHH_type_age_hh_10$end_age_P22)==table(dec_bgHH_type_age_hh_10$beg_age_P22)
length(test[test==FALSE])==0
nrow(dec_bgHH_type_age_hh_10)==nrow(dec_bgHHr_10)
#make sure that the "family" household type matches
test <- table(dec_bgHHr_10$geoid,dec_bgHHr_10$family)==
  table(dec_bgHH_type_age_hh_10$geoid,dec_bgHH_type_age_hh_10$family)
length(test[test==FALSE])==0
```

Unfortunately, P22 doesn't really give us a lot of information. The household type is only broken into family or non-family and the age_groups are by decade. If we add it quickly to H18, which has tenure by household type by three large age_ranges, it gives us more specificity while also demonstrating another type of issue that emerges when constructing our overall representation with categories that aren't exactly the same. The way to deal with overlaps, when building from relations within commutative structures, is through ensuring that the ordering is maintained. We implement this technically, below.

```{r download hhtype age bg}
dec_bgHH_type_tenure_age_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "H18",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_type_tenure_age_data_10 <- as.data.table(dec_bgHH_type_tenure_age_data_from_census_10)
dec_bgHH_type_tenure_age_data_10[,4:ncol(dec_bgHH_type_tenure_age_data_10)] <- 
  dec_bgHH_type_tenure_age_data_10[,lapply(.SD[,4:ncol(dec_bgHH_type_tenure_age_data_10)], as.numeric)]
```

Then do our basic checks (totals don't sum because "concept" doesn't follow same rules as most other tables; I haven't found the time to account for it in the tests.R script):

```{r household type tenure age test problems}
check_summary <- census_table_check(dec_bgHH_type_tenure_age_data_10, 
      "TENURE BY HOUSEHOLD TYPE BY AGE OF HOUSEHOLDER","households") 
cat(check_summary[1])
```

And do the expansion

```{r expand hhtype tenure age age of householder}
dec_bgHH_type_tenure_age_10 <- dec_bgHH_type_tenure_age_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_type_tenure_age_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(label = str_remove_all(label,"Other family!!"),
         label = str_replace_all(label, "er, no","er!!No"),
         label = str_replace_all(label, "!!Husband-wife family","!!Husband-wife family!!Married"),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% 
  separate(label, c("tenure","family","sex_hh","family_details","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(age_range = case_when(age_range=="Householder 65 years and over" ~ "Householder 65 to 99",
                               TRUE ~ age_range),
         beg_age_H18 = as.numeric(substr(age_range,13,14)),
         end_age_H18 = as.numeric(substr(age_range,19,20))) %>%
  filter(!is.na(age_range)) %>% 
  uncount(number_sams,.id = "hh_type_tenure_age_id",.remove = TRUE) 
dec_bgHH_type_tenure_age_10 <- as.data.table(dec_bgHH_type_tenure_age_10) #dyplyr had stripped it of dt
paste0("Number of households in file: ", nrow(dec_bgHH_type_tenure_age_10))
test <- table(dec_bgHH_type_tenure_age_10$end_age_H18)==table(dec_bgHH_type_tenure_age_10$beg_age_H18)
length(test[test==FALSE])==0
nrow(dec_bgHH_type_tenure_age_10)==nrow(dec_bgHHr_10)
#make sure that the "family" household type matches
test <- table(dec_bgHHr_10$geoid,dec_bgHHr_10$family)==
  table(dec_bgHH_type_tenure_age_10$geoid,dec_bgHH_type_tenure_age_10$family)
length(test[test==FALSE])==0
```

By creating the match id with the beginning age ("beg_age") in the ordering, we take advantage of how the other reporting has implicitly constrained (or specified) the space when building the representation. Order is part of the mathematical structure we want to maintain, at least when it matters to the original construction of the space within which each representation works. In this grouping, the process is very straightforward. We may be able to tweak the distribution within the categories later, but for now we note that the age_ranges line up, but just at different granularity (9 groups vs 3 groups), and that without any reason to do otherwise, we simply count off sequentially within those age_groups. We will lose some potential information about the relationships between age, sex, and tenure, within those three broad groups, but have no other way to specify the connection directly in any case. P29, relation in household, has householder by gender data that we will eventually be able to add.

```{r comparing H18 and P22 age_ranges}
table(dec_bgHH_type_age_hh_10$age_range)
table(dec_bgHH_type_tenure_age_10$age_range)
#for example...
nrow(dec_bgHH_type_age_hh_10[age_range=="Householder 15 to 24 years"])+
  nrow(dec_bgHH_type_age_hh_10[age_range=="Householder 25 to 34 years"])==
nrow(dec_bgHH_type_tenure_age_10[age_range=="Householder 15 to 34 years"]) 
table(dec_bgHH_type_tenure_age_10[,beg_age_H18],
      dec_bgHH_type_age_hh_10[,beg_age_P22])
```

Adding H18 to P22:

```{r join hh_type and age to create a better tenure with type and size data}
dec_bgHH_type_age_hh_10[order(family,beg_age_P22),
                        ("hh_tenure_age_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHH_type_tenure_age_10[order(family,beg_age_H18),
                            ("hh_tenure_age_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHH_type_tenure_age_10[,c("beg_age_P22","end_age_P22"):=
                    dec_bgHH_type_age_hh_10[.SD, c(list(beg_age_P22),list(end_age_P22)), 
                                            on = .(hh_tenure_age_match_id)]]
```

Tests for having moved over correctly! remember to do clean up stuff, too

```{r test tables expanded for P22 and H18}
nrow(dec_bgHH_type_tenure_age_10[is.na(beg_age_P22)])
test <- table(dec_bgHH_type_tenure_age_10[,geoid],
              dec_bgHH_type_tenure_age_10[,family],
              dec_bgHH_type_tenure_age_10[,beg_age_P22],
              dec_bgHH_type_tenure_age_10[,end_age_P22]
)==table(
  dec_bgHH_type_age_hh_10[,geoid],
  dec_bgHH_type_age_hh_10[,family],
  dec_bgHH_type_age_hh_10[,beg_age_P22],
  dec_bgHH_type_age_hh_10[,end_age_P22]
)
length(test[test==F])==0
paste0("column names for dec_bgHH_type_tenure_age_10: ")
colnames(dec_bgHH_type_tenure_age_10)
table(dec_bgHH_type_tenure_age_10[,beg_age_H18],
      dec_bgHH_type_tenure_age_10[,beg_age_P22])
#have to think through when and where to rm()
```

The problem is that just adding those 9 groups into the three groups for H18 would create all sorts of unintentional and misleading relations - tenure, sex, and family details would all be distributed randomly (or worse, by an unknown structural artifact of how the data was stored) within the categories and would then create some odd pairings.

DO SOME TABLES THAT SHOW THE RELATIONS AND WHAT WE MIGHT EXPECT

The idea is to switch directions from which we think about the problem - it could be something we draw up as a species of adjunction, even?

Let's use the techniques we already have to also add H17, "Tenure by Age of Householder" (by race and ethnicity), which has the same 9 age groups, as well. Instead of just adding it to the existing, we'll construct a structured space that can help channel the disposition of household characteristics. We'll pay attention to the ways in which the construction around age can be grounded in a variety of commutative triangles - although we will find a couple of limits to the approach, as well. First, we'll pick up H17, then draw some of the structure from the main household table back down into it, add more structure from the other files with age data, and finally pull it back into the main household table.

```{r download tenure race / ethnicity age bg}
dec_bgHH_re_tenure_age_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "H17",county_num = "201",
                         block="block_group",api_type="dec/sf1",path_suff="est.csv")
dec_bgHH_re_tenure_age_data_10 <- as.data.table(dec_bgHH_re_tenure_age_data_from_census_10)
dec_bgHH_re_tenure_age_data_10[,4:ncol(dec_bgHH_re_tenure_age_data_10)] <- 
  dec_bgHH_re_tenure_age_data_10[,lapply(.SD[,4:ncol(dec_bgHH_re_tenure_age_data_10)], as.numeric)]
```

Then do our basic checks:

```{r household tenure race / ethnicity age test problems}
check_summary <- census_table_check(dec_bgHH_re_tenure_age_data_10, 
      "TENURE BY AGE OF HOUSEHOLDER","households") 
cat(check_summary[1])
```

And do the expansion

```{r expand race/ethnicity tenure by age of householder}
race_codes <- c("A","B","C","D","E","F","G")
dec_bgHHr_tenure_age_10 <- dec_bgHH_re_tenure_age_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_re_tenure_age_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(
    race = substr(name,5,5),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("tenure","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  #using the beg/end_age_P22, since they match.
  mutate(age_range = case_when(age_range=="Householder 85 years and over" ~ "Householder 85 to 99",
                               TRUE ~ age_range),
         beg_age_P22 = as.numeric(substr(age_range,13,14)),
         end_age_P22 = as.numeric(substr(age_range,19,20))) %>%
  filter(!is.na(age_range) & race%in%race_codes) %>% #to get rid of aggregations by family
  uncount(number_sams,.id = "hhr_tenure_age_id",.remove = TRUE) 
dec_bgHHr_tenure_age_10 <- as.data.table(dec_bgHHr_tenure_age_10) #dyplyr had stripped it of dt
paste0("Number of households in file: ", nrow(dec_bgHHr_tenure_age_10))

#and same for ethnicity
dec_bgHHe_tenure_age_10 <- dec_bgHH_re_tenure_age_data_10 %>%
  pivot_longer(4:ncol(dec_bgHH_re_tenure_age_data_10),names_to = "geoid", values_to = "number_sams") %>% 
  mutate(
    ethnicity = substr(name,5,5),
    label = str_remove_all(label,"Total!!")) %>%
  filter(label != "Total") %>% #keep only the ones that aren't aggregated
  separate(label, c("tenure","age_range"), sep = "!!", remove = F, convert = FALSE) %>%
  mutate(age_range = case_when(age_range=="Householder 85 years and over" ~ "Householder 85 to 99",
                               TRUE ~ age_range),
         beg_age_P22 = as.numeric(substr(age_range,13,14)),
         end_age_P22 = as.numeric(substr(age_range,19,20))) %>%
  filter(!is.na(age_range) & ethnicity%in%c("H","I")) %>% 
  uncount(number_sams,.id = "hhe_tenure_age_id",.remove = TRUE) 
dec_bgHHe_tenure_age_10 <- as.data.table(dec_bgHHe_tenure_age_10) #dyplyr had stripped it of dt
paste0("Number of households with ethnicity attributes in file: ", nrow(dec_bgHHe_tenure_age_10))
nrow(dec_bgHHe_10)==nrow(dec_bgHHe_tenure_age_10)
paste0("Colnames for dec_bgHHr_tenure_age_10: ")
colnames(dec_bgHHr_tenure_age_10)
paste0("Colnames for dec_bgHHr_10: ")
colnames(dec_bgHHr_10)
#should clean up
```

First, let's draw down some structure from the main household table by race (dec_bgHHr_10) and ethnicity (dec_bgHHe_10). Creating the structure in several steps allows the construction to conserve the relations insofar as they maintain commutativity as the operation through which units are to be added (i.e., not a multiplication of statistical distributions of individuals within a larger and larger dimensional space). We build commutative structures until all the pieces are included from as many angles as possible before adding them together as a constraint on the emergence of the individuals within that structured space.

```{r draw down type with family details and hh_size}
dec_bgHHr_tenure_age_10[,("hhr_fd_size_match_id"):=
                    paste0(geoid,race,tenure,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,tenure)]
dec_bgHHr_10[,("hhr_fd_size_match_id"):=
                    paste0(geoid,race,tenure,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,tenure)]
dec_bgHHr_tenure_age_10[,c("hh_size_n","family","family_details"):=
                    dec_bgHHr_10[.SD, c(list(hh_size_n),list(family),list(family_details)), 
                                            on = .(hhr_fd_size_match_id)]]
nrow(dec_bgHHr_tenure_age_10[is.na(hh_size_n)])
dec_bgHHe_tenure_age_10[,("hhr_fd_size_match_id"):=
                    paste0(geoid,ethnicity,tenure,as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,tenure)]
dec_bgHHe_10[,("hhr_fd_size_match_id"):=
                    paste0(geoid,ethnicity,tenure,as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,tenure)]
dec_bgHHe_tenure_age_10[,c("hh_size_n","family","family_details"):=
                    dec_bgHHe_10[.SD, c(list(hh_size_n),list(family),list(family_details)), 
                                            on = .(hhr_fd_size_match_id)]]
nrow(dec_bgHHe_tenure_age_10[is.na(hh_size_n)])
paste0("Colnames for dec_bgHHr_tenure_age_10: ")
colnames(dec_bgHHr_tenure_age_10)
paste0("Colnames for dec_bgHHr_type_10: ")
colnames(dec_bgHHr_10)
```

The above technique moved the relations into a new table, keeping family per block group and age per block group the same, but it loses the relation between age and household type (family or non-family).

```{r test for symmetry and if age by family is making sense}
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,family]
)==table(
  dec_bgHH_type_age_hh_10[,geoid],
  dec_bgHH_type_age_hh_10[,family]
)
length(test[test==F])==0
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,beg_age_P22]
)==table(
  dec_bgHH_type_age_hh_10[,geoid],
  dec_bgHH_type_age_hh_10[,beg_age_P22]
)
length(test[test==F])==0
#but unsurprisingly, it's False if:
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,family],
              dec_bgHHr_tenure_age_10[,beg_age_P22]
)==table(
  dec_bgHH_type_age_hh_10[,geoid],
  dec_bgHH_type_age_hh_10[,family],
  dec_bgHH_type_age_hh_10[,beg_age_P22]
)
length(test[test==F])==0
```

Our question is whether there's a technique that allows us to use the admittedly limited age and household type (family or non) information from P22 to nudge H17 into better shape. In other words, the random sample that places household type from the main household table into H17 should be guided, at least at the top level, by the structure of the official table on P22. We can do a int.seq on the age_ranges, as opposed to a sample, in order to preserve the ordered structure during the matching. Of course, we will also have to make sure it doesn't mess up the match on race/eth. It should maintain something of the structure from the main household table, just nudged back to these totals.

```{r use P22 to get age_ranges back on H17 by family or non}
dec_bgHHr_tenure_age_10[order(beg_age_P22),
                        ("hhr_ta_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHH_type_age_hh_10[order(beg_age_P22),
                        ("hhr_ta_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHHr_tenure_age_10[,c("age_range","beg_age_P22","end_age_P22"):=
                    dec_bgHH_type_age_hh_10[.SD, c(list(age_range),list(beg_age_P22),list(end_age_P22)), 
                                            on = .(hhr_ta_match_id)]]
nrow(dec_bgHHr_tenure_age_10[is.na(age_range)])==0

dec_bgHHe_tenure_age_10[order(beg_age_P22),
                        ("hhe_ta_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHH_type_age_hh_10[order(beg_age_P22),
                        ("hhe_ta_match_id"):=
                    paste0(geoid,family,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,family)]
dec_bgHHe_tenure_age_10[,c("age_range","beg_age_P22","end_age_P22"):=
                    dec_bgHH_type_age_hh_10[.SD, c(list(age_range),list(beg_age_P22),list(end_age_P22)), 
                                            on = .(hhe_ta_match_id)]]
nrow(dec_bgHHe_tenure_age_10[is.na(age_range)])==0
#with the table that was false before:
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,family],
              dec_bgHHr_tenure_age_10[,beg_age_P22]
)==table(
  dec_bgHH_type_age_hh_10[,geoid],
  dec_bgHH_type_age_hh_10[,family],
  dec_bgHH_type_age_hh_10[,beg_age_P22]
)
length(test[test==F])==0
#can't test ethnicity, since it doesn't total to the same... need to think through some other test

paste0("Colnames for H17 dec_bgHHr_tenure_age_10: ")
colnames(dec_bgHHr_tenure_age_10)
paste0("Colnames for H18 dec_bgHH_type_tenure_age_10: ")
colnames(dec_bgHH_type_tenure_age_10)
```

Now let's see if we can get H17 and H18 together. One thing to watch here is whether the gender ("sex") of the householder reflects the underlying relation to race. In the data provided, it only correlates insofar as it is structured along with tenure and age. We may have an opportunity to nudge it later. There is fairly little data on sex and race in the household tables, with some obvious flaws in how it is originally collected and assigned, as well (including assigning "male" to head of household when married, which is apparently no longer universally required, but is not reported in the public tables on households).

Start with a couple of tables to see what already matches. Before we can do that, we have to tidy up the category names for family_details.

```{r cleaning up family_details so they match across tables}
dec_bgHHr_tenure_age_10[,("family_details_1"):=
                          fcase(family_details=="Female householder, no husband present",
                                  "No husband present",
                                family_details=="Male householder, no wife present",
                                  "No wife present",
                                family_details=="Husband-wife family",
                                  "Married",
                                family_details=="Householder living alone",
                                  "Living alone",
                                family_details=="Householder not living alone",
                                  "Not living alone"
                                )]
dec_bgHHr_tenure_age_10[,("sex"):=
                              fcase(family_details=="Female householder, no husband present",
                                  "Female",
                                family_details=="Male householder, no wife present",
                                  "Male",
                                family_details=="Husband-wife family",
                                  "Male", #I believe at some point they stopped making husbands automatically so
                                family_details=="Householder living alone",
                                  "NK",
                                family_details=="Householder not living alone",
                                  "NK"
                                )]
dec_bgHHe_tenure_age_10[,("family_details_1"):=
                          fcase(family_details=="Female householder, no husband present",
                                  "No husband present",
                                family_details=="Male householder, no wife present",
                                  "No wife present",
                                family_details=="Husband-wife family",
                                  "Married",
                                family_details=="Householder living alone",
                                  "Living alone",
                                family_details=="Householder not living alone",
                                  "Not living alone"
                                )]
dec_bgHHe_tenure_age_10[,("sex"):=
                              fcase(family_details=="Female householder, no husband present",
                                  "Female",
                                family_details=="Male householder, no wife present",
                                  "Male",
                                family_details=="Husband-wife family",
                                  "Male", #I believe at some point they stopped making husbands automatically so
                                family_details=="Householder living alone",
                                  "NK",
                                family_details=="Householder not living alone",
                                  "NK"
                                )]
dec_bgHH_type_tenure_age_10[,("sex"):=
                              fcase(sex_hh=="Female householder",
                                    "Female",
                                    sex_hh=="Male householder",
                                    "Male",
                                    sex_hh=="Husband-wife family",
                                    "Male"
                                    )]
```

```{r test tables for H17 and H18 on tenure family}
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,tenure]
)==table(
  dec_bgHH_type_tenure_age_10[,geoid],
  dec_bgHH_type_tenure_age_10[,tenure]
)
length(test[test==F])==0
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHH_type_tenure_age_10[,geoid],
  dec_bgHH_type_tenure_age_10[,family_details]
)
length(test[test==F])==0
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,tenure],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHH_type_tenure_age_10[,geoid],
  dec_bgHH_type_tenure_age_10[,tenure],
  dec_bgHH_type_tenure_age_10[,family_details]
)
length(test[test==F])==0
```

As with our earlier example, the relation of the individual categories to the block group is maintained, but the relation between the two categories is broken. Since we know that sex and family are tied tightly to family_details, we need only look at whether the triangle commutativity works on family_details. The situation is familiar - in fact, we have run into it before, with household size, and will have to generate some best practices as the matching becomes ever more complicated and the tables fail to provide enough structure to achieve a full match. 

[might look at a diagram or some sort of overall drawing] Need to get sex and to overwrite family and family details on H17, but ordered by those values from hh, matched on age and tenure. 

Here, we begin by creating a category on H17 that maps the 9 age ranges into the 3 on H18. Then we will order the family_details broadly so they go from most likely to be a male to most likely to be a female. The rest of the matching makes some mixing possible, but it's an admittedly coarse tool. We'll look at the details, later.

```{r control sex and add age by order}
#create an age_range_3 on H17
dec_bgHHr_tenure_age_10[,("age_range_3"):=
                          fcase(beg_age_P22 < 34,
                                "Householder 15 to 34 years",
                                beg_age_P22 < 64,
                                "Householder 35 to 64 years",
                                default = "Householder 65 to 99"
                                )]
dec_bgHHr_tenure_age_10[order(match(family_details_1,
                                    c("No wife present","Married","Living alone",
                                      "Not living alone","No husband present"))),
                        ("hhr_ffds_match_id"):=
                    paste0(geoid,tenure,age_range_3,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure,age_range_3)]
dec_bgHH_type_tenure_age_10[order(match(family_details,
                                    c("No wife present","Married","Living alone",
                                      "Not living alone","No husband present"))),
                        ("hhr_ffds_match_id"):=
                    paste0(geoid,tenure,age_range,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure,age_range)]
dec_bgHHr_tenure_age_10[,c("family","family_details","sex","sex_hh"):=
                    dec_bgHH_type_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhr_ffds_match_id)]]
dec_bgHH_type_tenure_age_10[,("matched_H16r"):=
                              dec_bgHHr_tenure_age_10[.SD, list(sex_hh),
                                            on = .(hhr_ffds_match_id)]]
dec_bgHHe_tenure_age_10[,("age_range_3"):=
                          fcase(beg_age_P22 < 34,
                                "Householder 15 to 34 years",
                                beg_age_P22 < 64,
                                "Householder 35 to 64 years",
                                default = "Householder 65 to 99"
                                )]
dec_bgHHe_tenure_age_10[order(match(family_details_1,
                                    c("No wife present","Married","Living alone",
                                      "Not living alone","No husband present"))),
                        ("hhe_ffds_match_id"):=
                    paste0(geoid,tenure,age_range_3,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure,age_range_3)]
dec_bgHH_type_tenure_age_10[order(match(family_details,
                                    c("No wife present","Married","Living alone",
                                      "Not living alone","No husband present"))),
                        ("hhe_ffds_match_id"):=
                    paste0(geoid,tenure,age_range,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure,age_range)]
dec_bgHHe_tenure_age_10[,c("family","family_details","sex","sex_hh"):=
                    dec_bgHH_type_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhe_ffds_match_id)]]
dec_bgHH_type_tenure_age_10[,("matched_H16e"):=
                              dec_bgHHe_tenure_age_10[.SD, list(sex_hh),
                                            on = .(hhe_ffds_match_id)]]
nrow(dec_bgHHr_tenure_age_10[is.na(sex_hh)])==0
paste0("Percent that didn't match on tenure and age_range on race: ", round(nrow(dec_bgHHr_tenure_age_10[is.na(sex_hh)])/nrow(dec_bgHHr_tenure_age_10[!is.na(sex_hh)])),2,"%")
paste0("But we are catching that difference: ",
nrow(dec_bgHH_type_tenure_age_10[is.na(matched_H16r)])==nrow(dec_bgHHr_tenure_age_10[is.na(sex_hh)]))
paste0("Although not on ethnicity (not sure why): ",
nrow(dec_bgHH_type_tenure_age_10[is.na(matched_H16e)])==nrow(dec_bgHHe_tenure_age_10[is.na(sex_hh)]))
```

There's a little over 2 percent that didn't match in the race table, and a similar percentage in the ethnicity table for which we did not show a calculation. To finish the matching process, we can just take out the ones that didn't match and use the ordering trick on age_range. We had already silently added a block of code to identify the individuals for whom no match was found.
We want to spend a little time trying to understand why there wasn't a match, especially since the ethnicity file had more issues. We will create a wrk file on the mismatched segments of the tables, which will allow us to examine them separately and to finish the matching on that specific and smaller group.

```{r exploring flaws in match from H16 to H17 (need work files for next chunk, too)}
wrk_dec_bgHHr_tenure_age_10 <- dec_bgHHr_tenure_age_10[is.na(sex_hh)]
r_wrk_dec_bgHH_type_tenure_age_10 <- dec_bgHH_type_tenure_age_10[is.na(matched_H16r)]
#look at some tables comparing them - need to really dive in to figure it out

wrk_dec_bgHHe_tenure_age_10 <- dec_bgHHe_tenure_age_10[is.na(sex_hh)]
e_wrk_dec_bgHH_type_tenure_age_10 <- dec_bgHH_type_tenure_age_10[is.na(matched_H16e)]
```

```{r finishing the matches from H16 to H17}
#because I can't get the selection and the ordering to work in the same call, we use wrk files from above
#put them back to full table matching on original match_id, since it's unique
wrk_dec_bgHHr_tenure_age_10[order(beg_age_P22),
                        ("hhr2_ffds_match_id"):=
                    paste0(geoid,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure)]
r_wrk_dec_bgHH_type_tenure_age_10[order(beg_age_H18),
                        ("hhr2_ffds_match_id"):=
                    paste0(geoid,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure)]
wrk_dec_bgHHr_tenure_age_10[,c("family","family_details","sex","sex_hh"):=
                    r_wrk_dec_bgHH_type_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhr2_ffds_match_id)]]
wrk_dec_bgHHr_tenure_age_10[,("hhr3_ffds_match_id"):=
                    paste0(geoid,as.character(100000+seq.int(1:.N))),
                  by=.(geoid)]
dec_bgHHr_tenure_age_10[is.na(sex_hh),("hhr3_ffds_match_id"):=
                    paste0(geoid,as.character(100000+seq.int(1:.N))),
                  by=.(geoid)]
dec_bgHHr_tenure_age_10[is.na(sex_hh),c("family","family_details","sex","sex_hh"):=
                          wrk_dec_bgHHr_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhr3_ffds_match_id)]]   
nrow(wrk_dec_bgHHr_tenure_age_10[is.na(sex_hh)])==0
nrow(dec_bgHHr_tenure_age_10[is.na(sex_hh)])==0
#and ethnicity
wrk_dec_bgHHe_tenure_age_10[order(beg_age_P22),
                        ("hhe2_ffds_match_id"):=
                    paste0(geoid,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure)]
e_wrk_dec_bgHH_type_tenure_age_10[order(beg_age_H18),
                        ("hhe2_ffds_match_id"):=
                    paste0(geoid,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid,tenure)]
wrk_dec_bgHHe_tenure_age_10[,c("family","family_details","sex","sex_hh"):=
                    e_wrk_dec_bgHH_type_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhe2_ffds_match_id)]]
wrk_dec_bgHHe_tenure_age_10[,("hhe3_ffds_match_id"):=
                    paste0(geoid,as.character(100000+seq.int(1:.N))),
                  by=.(geoid)]
dec_bgHHe_tenure_age_10[is.na(sex_hh),("hhe3_ffds_match_id"):=
                    paste0(geoid,as.character(100000+seq.int(1:.N))),
                  by=.(geoid)]
dec_bgHHe_tenure_age_10[is.na(sex_hh),c("family","family_details","sex","sex_hh"):=
                          wrk_dec_bgHHe_tenure_age_10[.SD, c(list(family),list(family_details_1),list(sex),list(sex_hh)), 
                                            on = .(hhe3_ffds_match_id)]]   
nrow(wrk_dec_bgHHe_tenure_age_10[is.na(sex_hh)])==0
nrow(dec_bgHHe_tenure_age_10[is.na(sex_hh)])==0
```

Have to think about what tests to use - right now, just looking at it to make sure there aren't na, etc. In the below, it breaks with tenure added in. 

```{r test result tables for H17 and H18 on family sex}
nrow(dec_bgHHr_tenure_age_10[is.na(sex_hh)])/nrow(dec_bgHHr_tenure_age_10[!is.na(sex_hh)])
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              #dec_bgHHr_tenure_age_10[,tenure],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHH_type_tenure_age_10[,geoid],
  #dec_bgHH_type_tenure_age_10[,tenure],
  dec_bgHH_type_tenure_age_10[,family_details]
)
length(test[test==F])==0
```

Our next step for the matching is to get the construction for household type family details and sex onto the main household table. After that, we will refine the race and ethnicity portions, from which we can expand into the full population representation. (see making_sam_full_pop.Rmd) 

Let's look at that main table and see what does and does not match with the table we constructed for the household type and family details. (More family details will be added later, of course). 

```{r preliminary comparisons for taking household family_details back to main table}
#have to create the match on family_details_1
dec_bgHHr_10[,("family_details_1"):=
                          fcase(family_details=="Female householder, no husband present",
                                  "No husband present",
                                family_details=="Male householder, no wife present",
                                  "No wife present",
                                family_details=="Husband-wife family",
                                  "Married",
                                family_details=="Householder living alone",
                                  "Living alone",
                                family_details=="Householder not living alone",
                                  "Not living alone"
                                )]
dec_bgHHe_10[,("family_details_1"):=
                          fcase(family_details=="Female householder, no husband present",
                                  "No husband present",
                                family_details=="Male householder, no wife present",
                                  "No wife present",
                                family_details=="Husband-wife family",
                                  "Married",
                                family_details=="Householder living alone",
                                  "Living alone",
                                family_details=="Householder not living alone",
                                  "Not living alone"
                                )]
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,tenure],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHHr_10[,geoid],
  dec_bgHHr_10[,tenure],
  dec_bgHHr_10[,family_details_1]
)
length(test[test==F])==0
#how many more do I need to match? age is not on there yet, size?
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,hh_size_n],
              dec_bgHHr_tenure_age_10[,tenure],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHHr_10[,geoid],
  dec_bgHHr_10[,hh_size_n],
  dec_bgHHr_10[,tenure],
  dec_bgHHr_10[,family_details_1]
)
length(test[test==F])==0
#race
test <- table(dec_bgHHr_tenure_age_10[,geoid],
              dec_bgHHr_tenure_age_10[,race],
              dec_bgHHr_tenure_age_10[,hh_size_n],
              dec_bgHHr_tenure_age_10[,tenure],
              dec_bgHHr_tenure_age_10[,family_details_1]
)==table(
  dec_bgHHr_10[,geoid],
  dec_bgHHr_10[,race],
  dec_bgHHr_10[,hh_size_n],
  dec_bgHHr_10[,tenure],
  dec_bgHHr_10[,family_details_1]
)
length(test[test==F])==0
#I think this means that all of these match the originals - can check to ensure...
#then same for ethnicity?
```

Given that it matches on all those levels, we need to move age information over while accounting for all those structures; age information should match the originals for x, y, and z - need to go through and understand what was lost and where.

```{r add age to main household file}
dec_bgHHr_10[,("hhr_age_match_id"):=
                    paste0(geoid,race,hh_size_n,tenure,family_details_1,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size_n,tenure,family_details_1)]
dec_bgHHr_tenure_age_10[,("hhr_age_match_id"):=
                    paste0(geoid,race,hh_size_n,tenure,family_details_1,as.character(100000+sample(1:.N))),
                  by=.(geoid,race,hh_size_n,tenure,family_details_1)]
dec_bgHHr_10[,c("age_range","age_beg","age_end","sex","sex_hh"):=
                    dec_bgHHr_tenure_age_10[.SD, c(list(age_range),list(beg_age_P22),list(end_age_P22),list(sex),list(sex_hh)), 
                                            on = .(hhr_age_match_id)]]
nrow(dec_bgHHr_10[is.na(age_range)])

dec_bgHHe_10[,("hhe_age_match_id"):=
                    paste0(geoid,ethnicity,hh_size_n,tenure,family_details_1,as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,hh_size_n,tenure,family_details_1)]
dec_bgHHe_tenure_age_10[,("hhe_age_match_id"):=
                    paste0(geoid,ethnicity,hh_size_n,tenure,family_details_1,as.character(100000+sample(1:.N))),
                  by=.(geoid,ethnicity,hh_size_n,tenure,family_details_1)]
dec_bgHHe_10[,c("age_range","age_beg","age_end","sex","sex_hh"):=
                    dec_bgHHe_tenure_age_10[.SD, c(list(age_range),list(beg_age_P22),list(end_age_P22),list(sex),list(sex_hh)), 
                                            on = .(hhe_age_match_id)]]
nrow(dec_bgHHe_10[is.na(age_range)])
```

Do tests and say something about what it means for these to be empty specifications (terminal objects) up to a certain point. There are other clues to householder age in some of the other tables, but I haven't taken the time to incorporate them (yet). 

##Adding race and ethnicity to the households

We can't add both the race and ethnicity files as specifications to the type and tenure table, because we don't know how the race and ethnicity relate to each other outside the white population. Luckily, HCT1 actually gives that detailed information for tenure status, and so allows some specification, albeit at the tract level and not block group. Let's use it to join the race and ethnicity tables from H17, although we will note a potential loss of information around age, and around the move from block group to tract, we will see that it's a remarkably tight representation across the diverse geographies. Moving from one level of encompassing relation and then specifying to a smaller level is what we get more broadly from the idea of embedding. The difference between embedding and layering will come up later, but has to do with how you think about the entailment structures inherent to embedding and (its complement) construction.

```{r get tenure by full race by ethnicity}
dec_trHH_fullre_tenure_data_from_census_10 <- 
  censusData_byGroupName(censusdir, vintage="2010", state, censuskey, 
                         groupname = "HCT1",county_num = "201",
                         block="tract",api_type="dec/sf1",path_suff="est.csv")
dec_trHH_fullre_tenure_data_10 <- as.data.table(dec_trHH_fullre_tenure_data_from_census_10)
dec_trHH_fullre_tenure_data_10[,4:ncol(dec_trHH_fullre_tenure_data_10)] <- 
  dec_trHH_fullre_tenure_data_10[,lapply(.SD[,4:ncol(dec_trHH_fullre_tenure_data_10)], as.numeric)]
```

```{r expand tract ethnicity by race of householder}
dec_trHH_fullre_tenure_10 <- dec_trHH_fullre_tenure_data_10 %>%
  pivot_longer(4:ncol(dec_trHH_fullre_tenure_data_10),names_to = "tract", values_to = "number_sams") %>% 
  filter(label != "Total" & str_detect(tract,"48201")) %>% 
  mutate(label = str_remove_all(label,"Total!!"),
         label = tolower(str_remove_all(label,"Householder who is ")),
         geoid13 = paste0("48_201_",substr(tract,6,12))) %>%
  separate(label, c("tenure","eth_H","race_full"), sep = "!!", remove = F, convert = FALSE) %>%
  #H and I are backwards from current standard - cf. https://www.census.gov/programs-surveys/acs/guidance/which-data-tool/table-ids-explained.html vs.the very clear labeling inside the labels downloaded for the others!!
  mutate(ethnicity = fcase(!str_detect(eth_H,"not"),"H",  
                           race_full!="white alone","O",
                           default = "I"), 
         race = fcase(race_full=="white alone","A",
                      str_detect(race_full,"black"),"B",
                      str_detect(race_full,"indian"),"C",
                      str_detect(race_full,"asian"),"D",
                      str_detect(race_full,"hawaiian"),"E",
                      str_detect(race_full,"other"),"F",
                      str_detect(race_full,"two"),"G",
                      str_detect(race_full,"not hispanic"),"I",  #not sure whether to invert these??
                      race_full=="hispanic or latino","H")
           ) %>%
  filter(!is.na(race_full)) %>% 
  uncount(number_sams,.id = "hh_tenure_eth_race_id",.remove = TRUE) 
dec_trHH_fullre_tenure_10 <- as.data.table(dec_trHH_fullre_tenure_10) #dyplyr had stripped it of dt
paste0("Number of households in file: ", nrow(dec_trHH_fullre_tenure_10))
nrow(dec_trHH_fullre_tenure_10)==nrow(dec_bgHHr_10)
test <- table(dec_trHH_fullre_tenure_10[,geoid13],
              dec_trHH_fullre_tenure_10[,race_full])==
  table(dec_bgHHr_10[,substr(geoid,1,14)],
        dec_bgHHr_10[,race_text])
length(test[test==FALSE])==0
test <- table(dec_trHH_fullre_tenure_10[ethnicity!="O",geoid13],
              dec_trHH_fullre_tenure_10[ethnicity!="O",ethnicity])==
  table(dec_bgHHe_10[,substr(geoid,1,13)],
        dec_bgHHe_10[,ethnicity])
length(test[test==FALSE])==0
colnames(dec_trHH_fullre_tenure_10)
```

Before joining with the race tables, however, let's make sure that we haven't lost any existing relations at the block group level that would tell us about race in relation to ethnicity. The structure we've just spent adding to the main household table already includes race and ethnicity, and this is really about adding specificity on the ethnicity of non-white Hispanic or Latino households. Making that distribution work at the block level is something that we hope the final join between ethnicity and race will make secure. All of the dec_bgHHe tables match on block group and ethnicity, which makes it possible to hold the commutative relations steady in the process of constructing the representation. Let's confirm with the ethnicity and tenure table:

```{r testing symmetries on block group ethnicity}
test <- table(dec_bgHHe_tenure_10[,geoid],
              dec_bgHHe_tenure_10[,ethnicity])==
      table(dec_bgHHe_10[,geoid],
            dec_bgHHe_10[,ethnicity])
    length(test[test==FALSE])==0
```

Given that test is "TRUE," we can join the block group specification from the main household table with the tract data, by ethnicity. 
Then when we join with the tables by race, all the dispositions of race by ethnicity will be properly assigned at the block group. We will use the tables we created by tenure and ethnicity to check whether this logic holds, as well. To make the matching a little easier, we make the geoid13 variable (i.e., tract without the block group) on the household, ethnicity, and tenure file in advance.

```{r join ethnicity table with full race/ethnicity and tenure table to get block groups}
dec_bgHHe_10[,("geoid13"):=substr(geoid,1,13)]
dec_bgHHe_10[,("tenure_lower"):=tolower(tenure)]
dec_trHH_fullre_tenure_10[ethnicity!="O",("hh_tenure_geoid_match_id"):=
                            paste0(geoid13,tenure,ethnicity,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,tenure,ethnicity)]
dec_bgHHe_10[,("hh_tenure_geoid_match_id"):=
                    paste0(geoid13,tenure_lower,ethnicity,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,tenure_lower,ethnicity)]
dec_trHH_fullre_tenure_10[ethnicity!="O",c("geoid","hh_size_n"):=
                    dec_bgHHe_10[.SD, c(list(geoid),list(hh_size_n)), 
                                            on = .(hh_tenure_geoid_match_id)]]
nrow(dec_bgHHe_tenure_10)==nrow(dec_trHH_fullre_tenure_10[!is.na(geoid)])
test <- table(dec_bgHHe_10[,geoid13],
              dec_bgHHe_10[,tenure_lower],
              dec_bgHHe_10[,ethnicity])==
      table(dec_trHH_fullre_tenure_10[ethnicity!="O",geoid13],
            dec_trHH_fullre_tenure_10[ethnicity!="O",tenure],
            dec_trHH_fullre_tenure_10[ethnicity!="O",ethnicity])
    length(test[test==FALSE])==0
```

We still need to join for all those we've labeled with an ethnicity of "O" (for "Other") - that is, everyone who is non-white and non-Hispanic/Latino. We now have geoid and household size on all the households with ethnicity of H or I, and the only issue is how to distribute the race by tenure within the block group. By having the household size as part of the commutative triangle, we are able to do so. But since our goal all along was to put ethnicity and race information back together on the household by race by tenure, we will use that file as the destination, allowing us to discard the table from HCT1. But to ensure that we have the right distributions for those groups, we will add more specification from the other files we have ethnicity data from. 

```{r join race table with full race/ethnicity to get block groups by race and ethnicity}
dec_bgHHr_10[,("geoid13"):=substr(geoid,1,13)]
dec_bgHHr_10[,("tenure_lower"):=tolower(tenure)]
dec_trHH_fullre_tenure_10[,("hh_full_geoid_match_id"):=
                            paste0(geoid13,race_full,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,race_full,tenure)]
dec_bgHHr_10[,("hh_full_geoid_match_id"):=
                    paste0(geoid13,race_text,tenure_lower,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,race_text,tenure_lower)]
dec_bgHHr_10[,("ethnicity"):=
                    dec_trHH_fullre_tenure_10[.SD, list(ethnicity), 
                                            on = .(hh_full_geoid_match_id)]]
test <- table(dec_bgHHr_10[,geoid13],
              dec_bgHHr_10[,tenure_lower],
              dec_bgHHr_10[,race_text],
              dec_bgHHr_10[,ethnicity])==
      table(dec_trHH_fullre_tenure_10[,geoid13],
            dec_trHH_fullre_tenure_10[,tenure],
            dec_trHH_fullre_tenure_10[,race_full],
            dec_trHH_fullre_tenure_10[,ethnicity])
length(test[test==FALSE])==0
colnames(dec_bgHHr_10)  
```


There is a potential of some places where race and ethnicity match at the tract level, but where we have some information that would point to them not matching at the block group level. To get a sense for how far apart those two are, let's build the same setup we just used, but add race to the main household by ethnicity table. Then we can compare the two representations and get a sense for how far apart they are and why. The last thing in this section will then be to use the ethnicity information to nudge the main table and to save the file before we move to expanding households into families and full populations. Since it has no data by block group on the specific disposition of non-white households by ethnicity, there may not be added advantage.

```{r join ethnicity table with full race/ethnicity to get block groups by race and ethnicity and compare}
dec_bgHHe_10[,("geoid13"):=substr(geoid,1,13)]
dec_bgHHe_10[,("tenure_lower"):=tolower(tenure)]
dec_trHH_fullre_tenure_10[,("hhe_full_geoid_match_id"):=
                            paste0(geoid13,ethnicity,tenure,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,ethnicity,tenure)]
dec_bgHHe_10[,("hhe_full_geoid_match_id"):=
                    paste0(geoid13,ethnicity,tenure_lower,as.character(100000+seq.int(1:.N))),
                  by=.(geoid13,ethnicity,tenure_lower)]
dec_bgHHe_10[,("race"):=
                    dec_trHH_fullre_tenure_10[.SD, list(race), 
                                            on = .(hhe_full_geoid_match_id)]]
test <- table(dec_bgHHe_10[,geoid],
              dec_bgHHe_10[,tenure_lower],
              dec_bgHHe_10[,race],
              dec_bgHHe_10[,ethnicity])==
      table(dec_trHH_fullre_tenure_10[ethnicity!="O",geoid],
            dec_trHH_fullre_tenure_10[ethnicity!="O",tenure],
            dec_trHH_fullre_tenure_10[ethnicity!="O",race],
            dec_trHH_fullre_tenure_10[ethnicity!="O",ethnicity])
length(test[test==FALSE])==0
colnames(dec_bgHHr_10)
```

How much do we want to go through the ethnicity tables to try to nudge? It's kind of laborious, after all. The below tables give us agreement on the totals, and even the matching tables, but not with full geoid - only with geoid13 (which is the tract level). That means that some of the folks are not in the right blocks. Interestingly, that's true of only about 30% of the blocks if you match on geoid, tenure, race and ethnicity: 70% had the same distribution within the blocks inside the tracts. If you look at the tract level, there's reasonably surprising exact matches (30%) on various triples of relations. Really need to think about how far they are apart and what it would mean to bring them any closer to each other.

```{r test for how far apart the main household tables are on race and ethnicity}
test <- table(dec_bgHHe_10[,geoid],
              #dec_bgHHe_10[,geoid13],
              dec_bgHHe_10[,tenure_lower],
              #dec_bgHHe_10[,hh_size_n],
              #dec_bgHHe_10[,family_details_1],
              #dec_bgHHe_10[,sex_hh],
              #dec_bgHHe_10[,age_beg],
              dec_bgHHe_10[,race],
              dec_bgHHe_10[,ethnicity])==
      table(dec_bgHHr_10[ethnicity!="O",geoid],
            #dec_bgHHr_10[ethnicity!="O",geoid13],
            dec_bgHHr_10[ethnicity!="O",tenure],
            #dec_bgHHr_10[ethnicity!="O",hh_size_n],
            #dec_bgHHr_10[ethnicity!="O",family_details_1],
            #dec_bgHHr_10[ethnicity!="O",sex_hh],
            #dec_bgHHr_10[ethnicity!="O",age_beg],
            dec_bgHHr_10[ethnicity!="O",race],
            dec_bgHHr_10[ethnicity!="O",ethnicity])
length(test[test==FALSE])==0
length(test[test==FALSE])/length(test)
test <- table(dec_bgHHe_10[,geoid13],
              dec_bgHHe_10[,tenure_lower],
              #dec_bgHHe_10[,hh_size_n],
              #dec_bgHHe_10[,family_details_1],
              dec_bgHHe_10[,sex_hh],
              #dec_bgHHe_10[,age_beg],
              dec_bgHHe_10[,race],
              dec_bgHHe_10[,ethnicity])==
      table(dec_bgHHr_10[ethnicity!="O",geoid13],
            dec_bgHHr_10[ethnicity!="O",tenure],
            #dec_bgHHr_10[ethnicity!="O",hh_size_n],
            #dec_bgHHr_10[ethnicity!="O",family_details_1],
            dec_bgHHr_10[ethnicity!="O",sex_hh],
            #dec_bgHHr_10[ethnicity!="O",age_beg],
            dec_bgHHr_10[ethnicity!="O",race],
            dec_bgHHr_10[ethnicity!="O",ethnicity])
length(test[test==FALSE])==0
length(test[test==FALSE])/length(test)
```


HOW FAR APART ARE THEY ON RACE AND ETH AT THE GEOID13??? IF THEY PASS SYMMETRY TEST AT THAT POINT, THEN ALL WE NEED TO DO IS LET ETHNICITY BE DETERMINED FROM THE TRACT LEVEL AND THEN ADD RACE BACK IN FROM THE BLOCK LEVEL - ALTHOUGH IT MIGHT BE INTERESTING TO SEE HOW THEY COMPOSE - FOR EXAMPLE, SHOULD WE SELECT ONLY THE SUBSET THAT ARE NON-WHITE HISPANIC TO DO THE MIX ON? 


```{r save households for Harris csv}
#need to check if exists and replace, if needed
    file_path <- valid_file_path(censusdir,vintage="2010",state,api_type="dec/sf1",block="block_group",groupname="bgHH_10",path_suff="wrk.csv")
    if(file.exists(file_path)){file.remove(file_path)}
    write_csv(dec_bgHHr_10,file_path)
```


